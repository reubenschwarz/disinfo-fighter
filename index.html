<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Information Fighter</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
  canvas { image-rendering: pixelated; image-rendering: crisp-edges; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
// ============================================================
// CONFIG — edit these to customise the game
// ============================================================
const CONFIG = {
  runDurationSeconds: 120, // ~60s waves + ~60s boss
  waveSchedule: [
    { time: 2,  enemies: [{ type: 'bruiser', count: 2 }] },
    { time: 12, enemies: [{ type: 'columnist', count: 2 }, { type: 'bruiser', count: 1 }] },
    { time: 22, enemies: [{ type: 'shouter', count: 2 }] },
    { time: 32, enemies: [{ type: 'bruiser', count: 1 }, { type: 'lobbyist', count: 1 }, { type: 'columnist', count: 1 }] },
    { time: 42, enemies: [{ type: 'shouter', count: 1 }, { type: 'bruiser', count: 2 }] },
    { time: 50, enemies: [{ type: 'lobbyist', count: 1 }, { type: 'columnist', count: 1 }, { type: 'shouter', count: 1 }] },
  ],
  bossSpawnTime: 60, // seconds until boss appears
  // Parody outlet names (change freely)
  enemyNames: {
    bruiser:    'Daily Tattler',
    columnist:  'The Austeralian',
    shouter:    'Faux News AU',
    lobbyist:   'Advance Aus™',
  },
  // Boss dialogue — safe parody defaults
  bossLinesParody: [
    "I have the best misinformation!",
    "Nobody spreads doubt like me!",
    "Tremendous confusion, believe me!",
    "I know more about hoaxes than anyone!",
    "Many people are saying… things!",
    "This is the greatest distraction ever!",
    "Fake? You're fake! Everything is fake!",
    "I alone can confuse the narrative!",
  ],
  // Optional: paste short real-world quotations here
  bossLinesOptionalRealQuotes: [],
  bubbleTexts: ['DOUBT', 'HOAX', 'JUST ASKING', 'BOTH SIDES', 'SUSPICIOUS', 'FAKE', 'WAKE UP'],
};

// ============================================================
// CONSTANTS
// ============================================================
const W = 320, H = 180;
const LANE_TOP = 100, LANE_BOT = 170;
const GROUND_Y = 150;

// NES palette (authentic Double Dragon colours)
const NES = {
  black:    0x000000, darkGrey:  0x747474, midGrey:   0xbcbcbc, white:     0xfcfcfc,
  darkRed:  0xa81000, red:       0xf83800, orange:    0xe45c10, peach:     0xfca044,
  brown:    0x503000, tan:       0xac7c00, yellow:    0xf8d878, ltYellow:  0xfce4a0,
  darkGreen:0x005800, green:     0x00b800, ltGreen:   0xb8f818, aqua:      0x58d854,
  darkBlue: 0x0058f8, blue:      0x3cbcfc, skyBlue:   0x6888fc, ltBlue:    0xa4e4fc,
  purple:   0x6844fc, magenta:   0xd800cc, pink:      0xf878f8, ltPink:    0xf8b8f8,
  teal:     0x008888, darkTeal:  0x004058, skin:      0xfcbcb0, darkSkin:  0xd8a060,
};

// ============================================================
// AUDIO ENGINE — Double Dragon style chiptune
// ============================================================
class ChipAudio {
  constructor() {
    this.ctx = null;
    this.musicGain = null;
    this.sfxGain = null;
    this.musicPlaying = false;
    this.currentTrack = null;
  }

  init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.musicGain = this.ctx.createGain();
    this.musicGain.gain.value = 0.15;
    this.musicGain.connect(this.ctx.destination);
    this.sfxGain = this.ctx.createGain();
    this.sfxGain.gain.value = 0.25;
    this.sfxGain.connect(this.ctx.destination);
  }

  resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }

  note(freq, dur, type = 'square', gain = null, delay = 0) {
    if (!this.ctx) return;
    const t = this.ctx.currentTime + delay;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(0.3, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    osc.connect(g);
    g.connect(gain || this.sfxGain);
    osc.start(t);
    osc.stop(t + dur);
  }

  noise(dur = 0.08) {
    if (!this.ctx) return;
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const src = this.ctx.createBufferSource();
    src.buffer = buf;
    const g = this.ctx.createGain();
    g.gain.setValueAtTime(0.2, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    src.connect(g);
    g.connect(this.sfxGain);
    src.start();
  }

  sfxPunch()   { this.note(180, 0.06, 'square'); this.noise(0.05); }
  sfxHit()     { this.note(100, 0.1, 'sawtooth'); this.noise(0.08); }
  sfxCombo()   { this.note(440, 0.05, 'square'); this.note(660, 0.05, 'square'); this.noise(0.04); }
  sfxCharged() { this.note(70, 0.18, 'sawtooth'); this.note(140, 0.12, 'square'); this.noise(0.12); }
  sfxBlock()   { this.note(280, 0.04, 'triangle'); }
  sfxEnemyDie(){ this.note(500, 0.04, 'square'); this.note(380, 0.06, 'square'); this.note(260, 0.1, 'triangle'); }
  sfxBossHit() { this.note(80, 0.15, 'sawtooth'); this.noise(0.12); }
  sfxWin()     { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.note(f, 0.3, 'square'), i*120)); }
  sfxLose()    { [300,250,200,150].forEach((f,i) => setTimeout(() => this.note(f, 0.4, 'sawtooth'), i*180)); }

  // Double Dragon-inspired stage music
  // Uses NES channel simulation: 2 pulse (square), 1 triangle bass, 1 noise percussion
  startMusic(track = 'stage') {
    if (this.musicPlaying) this.stopMusic();
    this.musicPlaying = true;
    this.currentTrack = track;

    if (track === 'stage') this._playStageMusic();
    else if (track === 'boss') this._playBossMusic();
  }

  _playStageMusic() {
    // Driving bassline (triangle) + energetic melody (pulse) — Double Dragon Mission 1 vibe
    // Key of E minor, 140 BPM → beat = ~0.428s, 16th = ~0.107s
    const BPM = 140;
    const beat = 60 / BPM;
    const s16 = beat / 4;

    // Bass pattern (E minor pentatonic, driving rhythm)
    const bassPattern = [
      82.41, 0, 82.41, 82.41, 110, 0, 98, 82.41,
      82.41, 0, 82.41, 82.41, 123.47, 0, 110, 98,
      73.42, 0, 73.42, 73.42, 98, 0, 82.41, 73.42,
      82.41, 0, 82.41, 98, 110, 0, 123.47, 110,
    ];

    // Melody (pulse 1) — heroic marching feel
    const melodyPattern = [
      659, 0, 659, 784, 880, 0, 784, 659,
      587, 0, 659, 0, 784, 0, 659, 0,
      587, 0, 587, 659, 784, 0, 880, 784,
      659, 0, 587, 0, 494, 0, 587, 0,
    ];

    // Harmony (pulse 2) — counter-melody, slightly behind
    const harmonyPattern = [
      330, 0, 330, 392, 440, 0, 392, 330,
      294, 0, 330, 0, 392, 0, 330, 0,
      294, 0, 294, 330, 392, 0, 440, 392,
      330, 0, 294, 0, 247, 0, 294, 0,
    ];

    let step = 0;
    this._musicInterval = setInterval(() => {
      if (!this.musicPlaying) return;
      const i = step % bassPattern.length;

      // Triangle bass
      if (bassPattern[i] > 0) this.note(bassPattern[i], s16 * 1.5, 'triangle', this.musicGain);
      // Pulse 1 melody
      if (melodyPattern[i] > 0) this.note(melodyPattern[i], s16 * 1.2, 'square', this.musicGain);
      // Pulse 2 harmony (quieter)
      if (harmonyPattern[i] > 0) {
        const g2 = this.ctx.createGain();
        g2.gain.value = 0.06;
        g2.connect(this.musicGain);
        this.note(harmonyPattern[i], s16 * 1.0, 'square', g2);
      }
      // Noise percussion on beats
      if (i % 4 === 0) {
        const nBuf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.04, this.ctx.sampleRate);
        const nD = nBuf.getChannelData(0);
        for (let j = 0; j < nD.length; j++) nD[j] = Math.random() * 2 - 1;
        const nSrc = this.ctx.createBufferSource();
        nSrc.buffer = nBuf;
        const nG = this.ctx.createGain();
        nG.gain.setValueAtTime(i % 8 === 0 ? 0.12 : 0.06, this.ctx.currentTime);
        nG.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.04);
        nSrc.connect(nG);
        nG.connect(this.musicGain);
        nSrc.start();
      }
      step++;
    }, s16 * 1000);
  }

  _playBossMusic() {
    // Menacing boss theme — lower key, heavier, more aggressive
    const BPM = 160;
    const s16 = (60 / BPM) / 4;

    const bassPattern = [
      55, 55, 0, 55, 65.41, 0, 55, 0,
      55, 55, 0, 55, 73.42, 0, 65.41, 0,
      49, 49, 0, 49, 55, 0, 65.41, 55,
      49, 49, 0, 65.41, 73.42, 0, 55, 0,
    ];

    const melodyPattern = [
      440, 0, 440, 523, 587, 0, 523, 440,
      392, 0, 440, 0, 523, 587, 523, 0,
      392, 0, 392, 440, 523, 0, 587, 523,
      440, 0, 523, 587, 659, 0, 587, 0,
    ];

    let step = 0;
    this._musicInterval = setInterval(() => {
      if (!this.musicPlaying) return;
      const i = step % bassPattern.length;
      if (bassPattern[i] > 0) this.note(bassPattern[i], s16 * 1.8, 'triangle', this.musicGain);
      if (melodyPattern[i] > 0) this.note(melodyPattern[i], s16 * 1.3, 'square', this.musicGain);
      // Heavy kick on every other beat
      if (i % 4 === 0) {
        const nBuf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.06, this.ctx.sampleRate);
        const nD = nBuf.getChannelData(0);
        for (let j = 0; j < nD.length; j++) nD[j] = Math.random() * 2 - 1;
        const nSrc = this.ctx.createBufferSource();
        nSrc.buffer = nBuf;
        const nG = this.ctx.createGain();
        nG.gain.setValueAtTime(0.15, this.ctx.currentTime);
        nG.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.06);
        nSrc.connect(nG);
        nG.connect(this.musicGain);
        nSrc.start();
      }
      step++;
    }, s16 * 1000);
  }

  stopMusic() {
    this.musicPlaying = false;
    if (this._musicInterval) clearInterval(this._musicInterval);
  }
}

const audio = new ChipAudio();

// ============================================================
// TEXTURE GENERATION — NES Double Dragon style pixel art
// ============================================================
function genTextures(scene) {

  // --- PLAYER: Double Dragon Billy Lee style (32x36) ---
  const pg = scene.make.graphics({ add: false });
  // Skin colour head
  pg.fillStyle(NES.skin);
  pg.fillRect(10, 2, 12, 10); // face
  pg.fillStyle(NES.darkSkin);
  pg.fillRect(10, 10, 12, 2); // chin shadow
  // Hair (spiky brown)
  pg.fillStyle(NES.brown);
  pg.fillRect(9, 0, 14, 5);
  pg.fillRect(8, 1, 2, 3);
  pg.fillRect(23, 1, 2, 4); // spikes
  pg.fillRect(25, 2, 1, 2);
  // Eyes
  pg.fillStyle(NES.black);
  pg.fillRect(13, 5, 2, 2);
  pg.fillRect(18, 5, 2, 2);
  // Blue sleeveless top (Double Dragon style)
  pg.fillStyle(NES.darkBlue);
  pg.fillRect(8, 12, 16, 10);
  pg.fillStyle(NES.blue);
  pg.fillRect(10, 13, 12, 8);
  // Arms (skin)
  pg.fillStyle(NES.skin);
  pg.fillRect(4, 13, 5, 8);  // left arm
  pg.fillRect(23, 13, 5, 8); // right arm
  pg.fillStyle(NES.darkSkin);
  pg.fillRect(4, 19, 5, 2);  // fists
  pg.fillRect(23, 19, 5, 2);
  // Belt
  pg.fillStyle(NES.yellow);
  pg.fillRect(9, 22, 14, 2);
  // Pants (dark)
  pg.fillStyle(NES.darkRed);
  pg.fillRect(9, 24, 6, 8);  // left leg
  pg.fillRect(17, 24, 6, 8); // right leg
  // Boots
  pg.fillStyle(NES.brown);
  pg.fillRect(8, 30, 7, 4);
  pg.fillRect(17, 30, 7, 4);
  // Clipboard in hand (the "fact-checker" touch)
  pg.fillStyle(NES.white);
  pg.fillRect(25, 15, 5, 6);
  pg.fillStyle(NES.black);
  pg.fillRect(26, 16, 3, 1);
  pg.fillRect(26, 18, 3, 1);
  pg.generateTexture('player', 32, 36);
  pg.destroy();

  // --- ENEMY SPRITES (NES style, ~24x32 each) ---
  function drawNESEnemy(key, shirtColor, shirtHighlight, pantsColor, w, h, bulky) {
    const g = scene.make.graphics({ add: false });
    const cx = Math.floor(w / 2);
    // Head
    g.fillStyle(NES.skin);
    g.fillRect(cx - 5, 2, 10, 9);
    g.fillStyle(NES.black);
    g.fillRect(cx - 5, 0, 10, 3); // hair
    g.fillRect(cx - 3, 5, 2, 2); // eyes
    g.fillRect(cx + 1, 5, 2, 2);
    // Body
    const bw = bulky ? 16 : 12;
    g.fillStyle(shirtColor);
    g.fillRect(cx - bw/2, 11, bw, 10);
    g.fillStyle(shirtHighlight);
    g.fillRect(cx - bw/2 + 2, 12, bw - 4, 7);
    // Arms
    g.fillStyle(NES.skin);
    g.fillRect(cx - bw/2 - 3, 12, 4, 7);
    g.fillRect(cx + bw/2 - 1, 12, 4, 7);
    // Belt
    g.fillStyle(NES.darkGrey);
    g.fillRect(cx - bw/2 + 1, 21, bw - 2, 2);
    // Pants
    g.fillStyle(pantsColor);
    g.fillRect(cx - 5, 23, 4, 7);
    g.fillRect(cx + 1, 23, 4, 7);
    // Boots
    g.fillStyle(NES.darkGrey);
    g.fillRect(cx - 6, 29, 5, 3);
    g.fillRect(cx + 1, 29, 5, 3);
    g.generateTexture(key, w, h);
    g.destroy();
  }

  drawNESEnemy('bruiser', NES.darkRed, NES.red, NES.darkGrey, 24, 32, true);
  drawNESEnemy('columnist', NES.brown, NES.orange, NES.darkTeal, 22, 32, false);
  drawNESEnemy('shouter', NES.purple, NES.magenta, NES.darkGrey, 22, 32, false);
  drawNESEnemy('lobbyist', NES.darkGreen, NES.green, NES.brown, 22, 32, false);

  // --- BOSS: Vladimir Impudent — stocky dictator parody (32x40) ---
  const bg = scene.make.graphics({ add: false });
  // Head (pale, stern)
  bg.fillStyle(NES.skin);
  bg.fillRect(9, 2, 14, 12);
  bg.fillStyle(NES.darkSkin);
  bg.fillRect(9, 12, 14, 2); // jaw
  // Receding hairline
  bg.fillStyle(NES.tan);
  bg.fillRect(10, 0, 12, 3);
  bg.fillRect(9, 1, 2, 2);
  bg.fillRect(21, 1, 2, 2);
  // Cold eyes
  bg.fillStyle(NES.darkBlue);
  bg.fillRect(12, 6, 3, 2);
  bg.fillRect(18, 6, 3, 2);
  bg.fillStyle(NES.black);
  bg.fillRect(13, 6, 1, 2);
  bg.fillRect(19, 6, 1, 2);
  // Mouth (stern line)
  bg.fillStyle(NES.darkSkin);
  bg.fillRect(14, 10, 5, 1);
  // Military-style jacket (dark green/olive)
  bg.fillStyle(0x2a5a00);
  bg.fillRect(5, 14, 22, 14);
  bg.fillStyle(0x3a7a10);
  bg.fillRect(8, 15, 16, 11);
  // Medals / decorations
  bg.fillStyle(NES.yellow);
  bg.fillRect(9, 16, 3, 2);
  bg.fillRect(9, 19, 3, 2);
  bg.fillStyle(NES.red);
  bg.fillRect(13, 16, 3, 2);
  bg.fillRect(13, 19, 3, 2);
  // Belt
  bg.fillStyle(NES.brown);
  bg.fillRect(7, 27, 18, 2);
  bg.fillStyle(NES.yellow);
  bg.fillRect(14, 27, 4, 2); // buckle
  // Arms
  bg.fillStyle(0x2a5a00);
  bg.fillRect(2, 15, 4, 10);
  bg.fillRect(26, 15, 4, 10);
  bg.fillStyle(NES.skin);
  bg.fillRect(2, 23, 4, 3); // fists
  bg.fillRect(26, 23, 4, 3);
  // Pants
  bg.fillStyle(NES.darkGrey);
  bg.fillRect(8, 29, 6, 8);
  bg.fillRect(18, 29, 6, 8);
  // Boots
  bg.fillStyle(NES.black);
  bg.fillRect(7, 35, 7, 4);
  bg.fillRect(18, 35, 7, 4);
  bg.generateTexture('boss', 32, 40);
  bg.destroy();

  // --- Projectile bubble ---
  const pb = scene.make.graphics({ add: false });
  pb.fillStyle(NES.white);
  pb.fillRoundedRect(0, 0, 28, 12, 4);
  pb.fillStyle(NES.midGrey);
  pb.fillRoundedRect(1, 1, 26, 10, 3);
  pb.fillStyle(NES.white);
  pb.fillRoundedRect(2, 2, 24, 8, 2);
  pb.generateTexture('bubble', 28, 12);
  pb.destroy();

  // --- Doubt cloud ---
  const dc = scene.make.graphics({ add: false });
  dc.fillStyle(0x666688);
  dc.fillCircle(20, 18, 18);
  dc.fillCircle(35, 14, 14);
  dc.fillCircle(10, 14, 12);
  dc.fillCircle(28, 10, 10);
  dc.generateTexture('doubtcloud', 50, 36);
  dc.destroy();

  // --- Hit spark (NES style 4-point star) ---
  const sp = scene.make.graphics({ add: false });
  sp.fillStyle(NES.white);
  sp.fillRect(5, 0, 2, 12);
  sp.fillRect(0, 5, 12, 2);
  sp.fillStyle(NES.yellow);
  sp.fillRect(4, 1, 4, 2);
  sp.fillRect(4, 9, 4, 2);
  sp.fillRect(1, 4, 2, 4);
  sp.fillRect(9, 4, 2, 4);
  sp.fillStyle(NES.red);
  sp.fillRect(5, 5, 2, 2);
  sp.generateTexture('spark', 12, 12);
  sp.destroy();

  // --- Confetti ---
  const cf = scene.make.graphics({ add: false });
  cf.fillStyle(NES.yellow);
  cf.fillRect(0, 0, 3, 3);
  cf.generateTexture('confetti', 3, 3);
  cf.destroy();
}

// ============================================================
// ENEMY LOGO BADGE — drawn as clear text plates above heads
// ============================================================
function createLogoBadge(scene, x, y, type) {
  const name = CONFIG.enemyNames[type] || type;
  // Coloured background plate matching enemy archetype
  const bgColors = { bruiser: '#cc2222', columnist: '#cc8800', shouter: '#8822aa', lobbyist: '#228822' };
  const badge = scene.add.text(x, y, ` ${name} `, {
    fontSize: '7px',
    fontFamily: 'Arial, Helvetica, sans-serif',
    fontStyle: 'bold',
    color: '#ffffff',
    backgroundColor: bgColors[type] || '#444444',
    padding: { x: 3, y: 2 },
  }).setOrigin(0.5).setDepth(30);
  return badge;
}

// ============================================================
// MAIN GAME SCENE
// ============================================================
class GameScene extends Phaser.Scene {
  constructor() { super('GameScene'); }

  create() {
    this.gameState = 'title';
    this.gameTime = 0;
    this.score = 0;
    this.stats = { combos: 0, bubblesPopped: 0, mythsBonked: 0 };
    this.waveIndex = 0;
    this.enemies = [];
    this.projectiles = [];
    this.doubtClouds = [];
    this.tutorialTimer = 0;
    this.shakeTimer = 0;
    this.cameraOffsetX = 0;

    genTextures(this);
    audio.init();

    this.drawBackground();
    this.player = this.createPlayer();
    this.createUI();

    // Controls
    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys = {
      w: this.input.keyboard.addKey('W'), a: this.input.keyboard.addKey('A'),
      s: this.input.keyboard.addKey('S'), d: this.input.keyboard.addKey('D'),
      j: this.input.keyboard.addKey('J'), k: this.input.keyboard.addKey('K'),
      l: this.input.keyboard.addKey('L'),
      shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
    };

    // Attack state
    this.attackTimer = 0;
    this.comboCount = 0;
    this.comboWindow = 0;
    this.chargeTimer = 0;
    this.isCharging = false;
    this.isBlocking = false;
    this.attackCooldown = 0;
    this.playerHitCooldown = 0;
    this.jumpVel = 0;
    this.isJumping = false;
    this.playerBaseY = GROUND_Y;

    // Boss
    this.boss = null;
    this.bossShoutTimer = 0;
    this.bossShoutText = null;
    this.bossAttackTimer = 0;
    this.bossPhase = 1;

    // Title screen — NES Double Dragon title style
    this.titleBg = this.add.rectangle(W / 2, H / 2, W, H, NES.black).setDepth(99);
    this.titleText = this.add.text(W / 2, 35, 'INFORMATION\n    FIGHTER', {
      fontSize: '18px', fontFamily: 'monospace', color: '#f83800', align: 'center',
      stroke: '#000000', strokeThickness: 2
    }).setOrigin(0.5).setDepth(100);
    this.titleSub = this.add.text(W / 2, 85, '— FIGHT MISINFORMATION —', {
      fontSize: '7px', fontFamily: 'monospace', color: '#fce4a0'
    }).setOrigin(0.5).setDepth(100);
    this.titleStart = this.add.text(W / 2, 120, 'PRESS  J  TO START', {
      fontSize: '8px', fontFamily: 'monospace', color: '#fcfcfc'
    }).setOrigin(0.5).setDepth(100);
    this.titleCredits = this.add.text(W / 2, 155, '© 2026 FACT-CHECKER STUDIOS', {
      fontSize: '5px', fontFamily: 'monospace', color: '#747474'
    }).setOrigin(0.5).setDepth(100);
    this.titleFlash = 0;

    // Tutorial overlay
    this.tutorialBg = this.add.rectangle(W / 2, H / 2, W - 16, H - 16, 0x000000, 0.92)
      .setDepth(90).setVisible(false).setScrollFactor(0);
    this.tutorialText = this.add.text(W / 2, H / 2, '', {
      fontSize: '7px', fontFamily: 'monospace', color: '#fce4a0', align: 'center', lineSpacing: 5
    }).setOrigin(0.5).setDepth(91).setVisible(false).setScrollFactor(0);

    // End screen
    this.endBg = this.add.rectangle(W / 2, H / 2, W, H, 0x000000, 0.92)
      .setDepth(100).setVisible(false).setScrollFactor(0);
    this.endText = this.add.text(W / 2, H / 2, '', {
      fontSize: '8px', fontFamily: 'monospace', color: '#ffffff', align: 'center', lineSpacing: 5
    }).setOrigin(0.5).setDepth(101).setVisible(false).setScrollFactor(0);
  }

  // --- NES Double Dragon BACKGROUND ---
  drawBackground() {
    // Dark night sky
    this.add.rectangle(W * 2.5, 50, W * 8, 100, 0x0c0820).setDepth(-10).setScrollFactor(0.05);

    // Stars
    for (let i = 0; i < 30; i++) {
      this.add.rectangle(Math.random() * W * 6, 5 + Math.random() * 40, 1, 1, NES.white)
        .setDepth(-9).setScrollFactor(0.05);
    }

    // Distant cityline silhouette (parallax far)
    for (let i = 0; i < 30; i++) {
      const bw = 15 + Math.random() * 25;
      const bh = 15 + Math.random() * 35;
      const bx = i * 55;
      this.add.rectangle(bx, 95 - bh/2, bw, bh, 0x101030).setDepth(-8).setScrollFactor(0.15);
    }

    // Mid-ground brick buildings
    for (let i = 0; i < 25; i++) {
      const bw = 25 + Math.random() * 35;
      const bh = 35 + Math.random() * 45;
      const bx = i * 65 - 20;
      const wallColor = [0x7c3820, 0x683018, 0x5c2810][Math.floor(Math.random() * 3)];
      this.add.rectangle(bx, LANE_TOP - bh/2 + 8, bw, bh, wallColor).setDepth(-6).setScrollFactor(0.35);
      // Brick pattern
      for (let row = 0; row < bh - 4; row += 5) {
        const offset = (Math.floor(row / 5) % 2) * 4;
        for (let col = 2 + offset; col < bw - 2; col += 8) {
          this.add.rectangle(bx - bw/2 + col + 3, LANE_TOP - bh + 8 + row + 4, 6, 3, wallColor + 0x111111)
            .setDepth(-5).setScrollFactor(0.35);
        }
      }
      // Windows (yellow glow or dark)
      for (let wy = 0; wy < bh - 12; wy += 12) {
        for (let wx = 5; wx < bw - 5; wx += 10) {
          const lit = Math.random() > 0.35;
          this.add.rectangle(bx - bw/2 + wx + 3, LANE_TOP - bh + 8 + wy + 7, 5, 6,
            lit ? 0xf8d878 : 0x302818).setDepth(-4).setScrollFactor(0.35);
        }
      }
    }

    // Street / ground (concrete grey with lane markings)
    this.add.rectangle(W * 3, LANE_TOP + 40, W * 8, 90, 0x484858).setDepth(-3).setScrollFactor(1);
    // Kerb
    this.add.rectangle(W * 3, LANE_TOP + 2, W * 8, 4, 0x888898).setDepth(-2).setScrollFactor(1);
    // Road markings
    for (let i = 0; i < 60; i++) {
      this.add.rectangle(i * 35, GROUND_Y + 8, 12, 2, 0x888844).setDepth(-1).setScrollFactor(1);
    }

    // Scattered props: trash cans, crates (Double Dragon staple)
    for (let i = 0; i < 12; i++) {
      const px = 80 + i * 120 + Math.random() * 40;
      const py = LANE_TOP + 8 + Math.random() * 10;
      if (Math.random() > 0.5) {
        // Trash can
        this.add.rectangle(px, py, 8, 12, 0x606060).setDepth(-1).setScrollFactor(1);
        this.add.rectangle(px, py - 7, 10, 2, 0x707070).setDepth(-1).setScrollFactor(1);
      } else {
        // Crate
        this.add.rectangle(px, py, 10, 10, 0x8c6c30).setDepth(-1).setScrollFactor(1);
        this.add.rectangle(px, py, 8, 1, 0x6c4c20).setDepth(-1).setScrollFactor(1);
        this.add.rectangle(px, py - 3, 1, 8, 0x6c4c20).setDepth(-1).setScrollFactor(1);
      }
    }
  }

  // --- PLAYER ---
  createPlayer() {
    const p = this.add.sprite(40, GROUND_Y, 'player').setDepth(10);
    p.hp = 100;
    p.maxHp = 100;
    p.damageMult = 1;
    return p;
  }

  // --- UI (NES style) ---
  createUI() {
    // Player HP
    this.add.rectangle(4, 3, 62, 8, NES.black).setOrigin(0).setScrollFactor(0).setDepth(50);
    this.hpBar = this.add.rectangle(5, 4, 60, 6, NES.green).setOrigin(0).setScrollFactor(0).setDepth(51);
    this.hpLabel = this.add.text(5, 12, 'FACT-CHECKER', {
      fontSize: '5px', fontFamily: 'monospace', color: '#3cbcfc'
    }).setScrollFactor(0).setDepth(51);

    // Boss HP (hidden)
    this.add.rectangle(W - 66, 3, 62, 8, NES.black).setOrigin(0).setScrollFactor(0).setDepth(50).setVisible(false);
    this.bossHpBg = this.add.rectangle(W - 66, 3, 62, 8, NES.black).setOrigin(0).setScrollFactor(0).setDepth(50).setVisible(false);
    this.bossHpBar = this.add.rectangle(W - 65, 4, 60, 6, NES.red).setOrigin(0).setScrollFactor(0).setDepth(51).setVisible(false);
    this.bossHpLabel = this.add.text(W - 65, 12, '', {
      fontSize: '5px', fontFamily: 'monospace', color: '#f83800'
    }).setScrollFactor(0).setDepth(51).setVisible(false);

    // Score + timer (top center, NES style)
    this.scoreText = this.add.text(W / 2, 2, 'SCORE 0', {
      fontSize: '7px', fontFamily: 'monospace', color: '#fcfcfc'
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);
    this.timerText = this.add.text(W / 2, 11, '', {
      fontSize: '5px', fontFamily: 'monospace', color: '#bcbcbc'
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);
  }

  // --- ENEMY SPAWNING ---
  spawnEnemy(type, x, y) {
    const e = this.add.sprite(x, y, type).setDepth(9);
    e.enemyType = type;
    e.hp = type === 'bruiser' ? 30 : 20;
    e.maxHp = e.hp;
    e.speed = type === 'bruiser' ? 0.7 : type === 'shouter' ? 0.35 : 0.45;
    e.attackCooldown = 0;
    e.attackRange = type === 'shouter' ? 100 : type === 'columnist' ? 50 : 22;
    e.stunTimer = 0;
    e.hitTimer = 0;
    e.dir = -1;

    // Logo badge (clear, non-8bit text plate)
    e.logoBadge = createLogoBadge(this, x, y - 20, type);

    // HP bar
    e.hpBg = this.add.rectangle(x - 10, y - 14, 20, 3, NES.black).setDepth(29);
    e.hpFill = this.add.rectangle(x - 10, y - 14, 20, 3, NES.red).setOrigin(0, 0.5).setDepth(29);

    this.enemies.push(e);
    return e;
  }

  spawnWave(waveDef) {
    const camX = this.cameras.main.scrollX;
    waveDef.enemies.forEach(eg => {
      for (let i = 0; i < eg.count; i++) {
        const x = camX + W + 20 + Math.random() * 50;
        const y = LANE_TOP + 25 + Math.random() * (LANE_BOT - LANE_TOP - 25);
        this.spawnEnemy(eg.type, x, y);
      }
    });
  }

  // --- BOSS ---
  spawnBoss() {
    const camX = this.cameras.main.scrollX;
    this.boss = this.add.sprite(camX + W - 30, GROUND_Y - 5, 'boss').setDepth(10);
    this.boss.hp = 100;
    this.boss.maxHp = 100;
    this.boss.stunTimer = 0;
    this.boss.hitTimer = 0;
    this.boss.attackCooldown = 60;
    this.boss.dir = -1;
    this.boss.dashTimer = 0;
    this.boss.windupTimer = 0;
    this.bossPhase = 1;
    this.bossShoutTimer = 0;

    this.bossHpBg.setVisible(true);
    this.bossHpBar.setVisible(true);
    this.bossHpLabel.setText('VLAD IMPUDENT').setVisible(true);

    this.bossShoutText = this.add.text(this.boss.x, this.boss.y - 30, '', {
      fontSize: '6px', fontFamily: 'monospace', color: '#f8d878', backgroundColor: '#200000dd',
      padding: { x: 3, y: 2 }, wordWrap: { width: 90 }
    }).setOrigin(0.5).setDepth(20);
    this.showBossShout();

    // Switch to boss music
    audio.stopMusic();
    audio.startMusic('boss');
  }

  getBossLines() {
    const lines = [...CONFIG.bossLinesParody];
    if (CONFIG.bossLinesOptionalRealQuotes.length > 0) lines.push(...CONFIG.bossLinesOptionalRealQuotes);
    return lines;
  }

  showBossShout() {
    if (!this.boss || !this.bossShoutText) return;
    const lines = this.getBossLines();
    this.bossShoutText.setText(lines[Math.floor(Math.random() * lines.length)]);
    this.bossShoutTimer = 480;
  }

  // --- PROJECTILE ---
  spawnProjectile(x, y, vx, vy, fromBoss = false) {
    const p = this.add.sprite(x, y, 'bubble').setDepth(11);
    p.vx = vx; p.vy = vy; p.fromBoss = fromBoss; p.life = 300;
    const txt = CONFIG.bubbleTexts[Math.floor(Math.random() * CONFIG.bubbleTexts.length)];
    p.label = this.add.text(x, y, txt, {
      fontSize: '5px', fontFamily: 'monospace', color: '#200000', fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(12);
    this.projectiles.push(p);
    return p;
  }

  spawnDoubtCloud(x, y) {
    const c = this.add.sprite(x, y, 'doubtcloud').setDepth(8).setAlpha(0.5);
    c.life = 300;
    this.doubtClouds.push(c);
    return c;
  }

  spawnSpark(x, y) {
    const s = this.add.sprite(x, y, 'spark').setDepth(15);
    this.tweens.add({ targets: s, alpha: 0, scaleX: 1.8, scaleY: 1.8, duration: 180, onComplete: () => s.destroy() });
  }

  spawnConfetti(x, y) {
    for (let i = 0; i < 10; i++) {
      const c = this.add.sprite(x, y, 'confetti').setDepth(15).setTint(
        [NES.red, NES.green, NES.blue, NES.yellow, NES.pink][Math.floor(Math.random() * 5)]
      );
      this.tweens.add({
        targets: c, x: x + (Math.random() - 0.5) * 50, y: y - 15 - Math.random() * 35,
        alpha: 0, duration: 500 + Math.random() * 300, onComplete: () => c.destroy()
      });
    }
  }

  getPlayerDamage(base) {
    let d = base * this.player.damageMult;
    for (const c of this.doubtClouds) {
      if (c.active && Phaser.Math.Distance.Between(this.player.x, this.player.y, c.x, c.y) < 30) {
        d *= 0.5; break;
      }
    }
    return Math.max(1, Math.floor(d));
  }

  // --- UPDATE ---
  update(time, delta) {
    const dt = delta / 1000;

    if (this.shakeTimer > 0) {
      this.shakeTimer--;
      this.cameras.main.setScroll(
        this.cameras.main.scrollX + (Math.random() - 0.5) * 2,
        (Math.random() - 0.5) * 2
      );
    }

    // TITLE
    if (this.gameState === 'title') {
      this.titleFlash += dt;
      this.titleStart.setAlpha(Math.sin(this.titleFlash * 3) * 0.5 + 0.5);
      if (Phaser.Input.Keyboard.JustDown(this.keys.j)) {
        audio.resume();
        this.titleBg.setVisible(false);
        this.titleText.setVisible(false);
        this.titleSub.setVisible(false);
        this.titleStart.setVisible(false);
        this.titleCredits.setVisible(false);
        this.gameState = 'tutorial';
        this.tutorialTimer = 420; // 7 seconds
        this.showTutorial();
        audio.startMusic('stage');
      }
      return;
    }

    // TUTORIAL
    if (this.gameState === 'tutorial') {
      this.tutorialTimer--;
      if (this.tutorialTimer <= 0) {
        this.tutorialBg.setVisible(false);
        this.tutorialText.setVisible(false);
        this.gameState = 'playing';
      }
      this.updatePlayer(dt);
      return;
    }

    // END SCREENS
    if (this.gameState === 'win' || this.gameState === 'lose') {
      if (Phaser.Input.Keyboard.JustDown(this.keys.j)) this.scene.restart();
      return;
    }

    // GAME TIMER
    this.gameTime += dt;
    const mins = Math.floor(this.gameTime / 60);
    const secs = Math.floor(this.gameTime % 60);
    this.timerText.setText(`${mins}:${secs.toString().padStart(2, '0')}`);

    // WAVE SPAWNING
    if (this.gameState === 'playing') {
      if (this.waveIndex < CONFIG.waveSchedule.length) {
        const w = CONFIG.waveSchedule[this.waveIndex];
        if (this.gameTime >= w.time) { this.spawnWave(w); this.waveIndex++; }
      }

      // Camera scroll
      if (this.gameTime < CONFIG.bossSpawnTime) {
        this.cameraOffsetX += 0.4;
        this.cameras.main.scrollX = this.cameraOffsetX;
      }

      // Boss intro when time reached and enemies cleared
      const allWavesDone = this.waveIndex >= CONFIG.waveSchedule.length;
      const noEnemies = this.enemies.filter(e => e.active).length === 0;
      if ((this.gameTime >= CONFIG.bossSpawnTime && noEnemies) || (allWavesDone && noEnemies && this.gameTime > 45)) {
        this.gameState = 'bossIntro';
        this.bossIntroTimer = 120;
        this.bossIntroText = this.add.text(W / 2, H / 2 - 15,
          'WARNING!!\n\nVLADIMIR IMPUDENT\n    APPROACHES!', {
          fontSize: '9px', fontFamily: 'monospace', color: '#f83800', align: 'center',
          stroke: '#000000', strokeThickness: 1
        }).setOrigin(0.5).setScrollFactor(0).setDepth(80);
      }
    }

    // BOSS INTRO
    if (this.gameState === 'bossIntro') {
      this.bossIntroTimer--;
      this.updatePlayer(dt);
      if (this.bossIntroTimer <= 0) {
        this.bossIntroText.destroy();
        this.gameState = 'bossFight';
        this.spawnBoss();
      }
      return;
    }

    // GAMEPLAY
    this.updatePlayer(dt);
    this.updateEnemies(dt);
    this.updateBoss(dt);
    this.updateProjectiles(dt);
    this.updateDoubtClouds(dt);
    this.updateUI();

    if (this.player.hp <= 0 && this.gameState !== 'lose') {
      this.gameState = 'lose';
      audio.stopMusic();
      audio.sfxLose();
      this.showEndScreen(false);
    }
  }

  showTutorial() {
    this.tutorialBg.setVisible(true);
    this.tutorialText.setText(
      '— CONTROLS —\n\n' +
      'MOVE:   Arrows / WASD\n' +
      'JUMP:   K\n' +
      'ATTACK: J  (tap-tap = combo)\n' +
      '        Hold J = charged hit\n' +
      'BLOCK:  L or Shift\n\n' +
      'Defeat the waves!\n' +
      'Pop bubbles. Bonk myths.'
    ).setVisible(true);
  }

  // --- PLAYER UPDATE ---
  updatePlayer(dt) {
    const p = this.player;
    const spd = 1.6;
    let mx = 0, my = 0;
    if (this.cursors.left.isDown || this.keys.a.isDown) mx = -1;
    if (this.cursors.right.isDown || this.keys.d.isDown) mx = 1;
    if (this.cursors.up.isDown || this.keys.w.isDown) my = -1;
    if (this.cursors.down.isDown || this.keys.s.isDown) my = 1;

    if (!this.isBlocking) {
      p.x += mx * spd;
      this.playerBaseY = Phaser.Math.Clamp(this.playerBaseY + my * spd * 0.7, LANE_TOP + 15, LANE_BOT);
    }

    const camL = this.cameras.main.scrollX + 10;
    const camR = this.cameras.main.scrollX + W - 10;
    p.x = Phaser.Math.Clamp(p.x, camL, camR);
    if (mx !== 0) p.setFlipX(mx < 0);

    // Jump
    if (Phaser.Input.Keyboard.JustDown(this.keys.k) && !this.isJumping) {
      this.isJumping = true;
      this.jumpVel = -4.5;
    }
    if (this.isJumping) {
      this.jumpVel += 0.22;
      p.y += this.jumpVel;
      if (p.y >= this.playerBaseY) { p.y = this.playerBaseY; this.isJumping = false; this.jumpVel = 0; }
    } else {
      p.y = this.playerBaseY;
    }

    // Block
    this.isBlocking = this.keys.l.isDown || this.keys.shift.isDown;
    if (this.isBlocking) p.setTint(NES.skyBlue);
    else if (!this.isCharging) p.clearTint();

    if (this.attackCooldown > 0) this.attackCooldown--;
    if (this.comboWindow > 0) this.comboWindow--;
    if (this.playerHitCooldown > 0) this.playerHitCooldown--;

    // Charge
    if (this.keys.j.isDown && !this.isBlocking) {
      this.chargeTimer++;
      if (this.chargeTimer > 30) { this.isCharging = true; p.setTint(NES.yellow); }
    }

    if (Phaser.Input.Keyboard.JustUp(this.keys.j) && this.attackCooldown <= 0 && !this.isBlocking) {
      if (this.isCharging && this.chargeTimer > 30) {
        this.performAttack(25, 28, true); audio.sfxCharged(); this.isCharging = false;
      } else if (this.comboWindow > 0 && this.comboCount >= 1) {
        this.performAttack(15, 22, false); this.comboCount++;
        if (this.comboCount >= 3) {
          this.stats.combos++;
          this.spawnConfetti(p.x + (p.flipX ? -15 : 15), p.y - 8);
          audio.sfxCombo(); this.comboCount = 0;
        } else { audio.sfxPunch(); }
      } else {
        this.performAttack(8, 20, false); this.comboCount = 1; audio.sfxPunch();
      }
      this.comboWindow = 30; this.attackCooldown = 12; this.chargeTimer = 0;
    }

    if (Phaser.Input.Keyboard.JustDown(this.keys.j)) { this.chargeTimer = 0; this.isCharging = false; }
    p.setDepth(10 + (p.y / H) * 0.1);
  }

  performAttack(damage, range, isCharged) {
    const p = this.player;
    const dir = p.flipX ? -1 : 1;
    const ax = p.x + dir * range / 2;
    const ay = p.y;
    this.spawnSpark(p.x + dir * 14, p.y - 8);

    for (const e of this.enemies) {
      if (!e.active) continue;
      if (Phaser.Math.Distance.Between(ax, ay, e.x, e.y) < range) {
        const dmg = this.getPlayerDamage(damage);
        e.hp -= dmg; e.hitTimer = 10;
        e.x += dir * (isCharged ? 14 : 6);
        e.setTint(NES.white);
        this.stats.mythsBonked++;
        if (e.hp <= 0) this.killEnemy(e);
      }
    }

    if (this.boss && this.boss.active) {
      if (Phaser.Math.Distance.Between(ax, ay, this.boss.x, this.boss.y) < range + 10) {
        const dmg = this.getPlayerDamage(damage);
        this.boss.hp -= dmg; this.boss.hitTimer = 10;
        this.boss.x += dir * (isCharged ? 8 : 3);
        this.boss.setTint(NES.white);
        audio.sfxBossHit();
        this.shakeTimer = isCharged ? 8 : 3;

        if (this.boss.hp <= this.boss.maxHp * 0.4 && this.bossPhase === 1) {
          this.bossPhase = 2;
          this.boss.setTint(NES.orange);
          this.showBossShout();
        }
        if (this.boss.hp <= 0) {
          this.boss.destroy();
          if (this.bossShoutText) this.bossShoutText.destroy();
          this.bossHpBg.setVisible(false);
          this.bossHpBar.setVisible(false);
          this.bossHpLabel.setVisible(false);
          this.boss = null;
          this.gameState = 'win';
          audio.stopMusic(); audio.sfxWin();
          this.shakeTimer = 15;
          this.spawnConfetti(p.x, p.y - 10);
          this.spawnConfetti(p.x + 20, p.y);
          this.spawnConfetti(p.x - 20, p.y);
          this.showEndScreen(true);
        }
      }
    }

    for (const pr of this.projectiles) {
      if (!pr.active) continue;
      if (Phaser.Math.Distance.Between(ax, ay, pr.x, pr.y) < range) {
        pr.label.destroy(); pr.destroy();
        this.stats.bubblesPopped++; this.score += 50;
      }
    }
  }

  killEnemy(e) {
    audio.sfxEnemyDie(); this.score += 100;
    this.spawnSpark(e.x, e.y - 8);
    if (e.logoBadge) e.logoBadge.destroy();
    if (e.hpBg) e.hpBg.destroy();
    if (e.hpFill) e.hpFill.destroy();
    e.destroy();
  }

  // --- ENEMY AI ---
  updateEnemies(dt) {
    for (const e of this.enemies) {
      if (!e.active) continue;
      if (e.hitTimer > 0) { e.hitTimer--; if (e.hitTimer <= 0) e.clearTint(); }
      if (e.stunTimer > 0) { e.stunTimer--; continue; }
      if (e.attackCooldown > 0) e.attackCooldown--;

      const dx = this.player.x - e.x, dy = this.player.y - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      e.dir = dx > 0 ? 1 : -1;
      e.setFlipX(e.dir < 0);

      if (dist > e.attackRange) {
        e.x += (dx / dist) * e.speed;
        e.y += (dy / dist) * e.speed * 0.5;
        e.y = Phaser.Math.Clamp(e.y, LANE_TOP + 10, LANE_BOT);
      }
      if (dist <= e.attackRange + 5 && e.attackCooldown <= 0) this.enemyAttack(e);

      // Update badge + hp position
      if (e.logoBadge && e.logoBadge.active) e.logoBadge.setPosition(e.x, e.y - 22);
      if (e.hpBg && e.hpBg.active) {
        e.hpBg.setPosition(e.x, e.y - 15);
        e.hpFill.setPosition(e.x - 10, e.y - 15);
        e.hpFill.width = 20 * Math.max(0, e.hp / e.maxHp);
      }
      e.setDepth(10 + (e.y / H) * 0.1);
    }
    this.enemies = this.enemies.filter(e => e.active);
  }

  enemyAttack(e) {
    const type = e.enemyType;
    if (type === 'bruiser') {
      e.x += e.dir * 10; this.hitPlayer(8, e); e.attackCooldown = 80;
    } else if (type === 'columnist') {
      this.hitPlayer(5, e);
      const ht = this.add.text(e.x + e.dir * 12, e.y - 18, 'HOT TAKE!', {
        fontSize: '6px', fontFamily: 'monospace', color: '#f8d878', backgroundColor: '#000000cc', padding: { x: 2, y: 1 }
      }).setOrigin(0.5).setDepth(20);
      this.tweens.add({ targets: ht, alpha: 0, y: e.y - 35, duration: 700, onComplete: () => ht.destroy() });
      e.attackCooldown = 110;
    } else if (type === 'shouter') {
      this.spawnProjectile(e.x, e.y - 5, e.dir * 1.4, 0);
      e.attackCooldown = 130;
    } else if (type === 'lobbyist') {
      this.spawnDoubtCloud(this.player.x + (Math.random() - 0.5) * 40, this.player.y);
      e.attackCooldown = 180;
    }
  }

  hitPlayer(damage, source) {
    if (this.playerHitCooldown > 0) return;
    if (this.isBlocking) { audio.sfxBlock(); damage = Math.floor(damage * 0.2); }
    this.player.hp -= damage;
    this.playerHitCooldown = 30;
    this.player.setTint(NES.red);
    this.time.delayedCall(200, () => { if (this.player.active && !this.isBlocking) this.player.clearTint(); });
    this.shakeTimer = 3;
  }

  // --- BOSS AI ---
  updateBoss(dt) {
    if (!this.boss || !this.boss.active) return;
    const b = this.boss;
    if (b.hitTimer > 0) { b.hitTimer--; if (b.hitTimer <= 0) b.clearTint(); }
    if (this.bossShoutTimer > 0) { this.bossShoutTimer--; if (this.bossShoutTimer <= 0) this.showBossShout(); }
    if (this.bossShoutText && this.bossShoutText.active) this.bossShoutText.setPosition(b.x, b.y - 30);

    if (b.stunTimer > 0) { b.stunTimer--; return; }
    if (b.attackCooldown > 0) b.attackCooldown--;

    const dx = this.player.x - b.x, dy = this.player.y - b.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    b.dir = dx > 0 ? 1 : -1;
    b.setFlipX(b.dir < 0);

    const moveSpd = this.bossPhase === 2 ? 0.9 : 0.45;

    if (b.dashTimer > 0) {
      b.dashTimer--;
      b.x += b.dir * 3.5;
      b.x = Phaser.Math.Clamp(b.x, this.cameras.main.scrollX + 12, this.cameras.main.scrollX + W - 12);
      return;
    }

    if (dist > 32) {
      b.x += (dx / dist) * moveSpd;
      b.y += (dy / dist) * moveSpd * 0.5;
      b.y = Phaser.Math.Clamp(b.y, LANE_TOP + 10, LANE_BOT);
    }

    if (b.attackCooldown <= 0) {
      if (this.bossPhase === 2 && Math.random() < 0.3) {
        b.dashTimer = 18; b.attackCooldown = 80;
        const wt = this.add.text(b.x, b.y - 24, '!!', {
          fontSize: '10px', fontFamily: 'monospace', color: '#f83800'
        }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets: wt, alpha: 0, duration: 350, onComplete: () => wt.destroy() });
      } else if (this.bossPhase === 2 && Math.random() < 0.4 && dist > 45) {
        const wt = this.add.text(b.x, b.y - 24, '!!!', {
          fontSize: '10px', fontFamily: 'monospace', color: '#f83800'
        }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets: wt, alpha: 0, duration: 450, onComplete: () => wt.destroy() });
        this.time.delayedCall(280, () => {
          if (!this.boss) return;
          this.spawnProjectile(b.x, b.y - 5, b.dir * 1.6, -0.5, true);
          this.spawnProjectile(b.x, b.y - 5, b.dir * 1.6, 0, true);
          this.spawnProjectile(b.x, b.y - 5, b.dir * 1.6, 0.5, true);
        });
        b.attackCooldown = 110;
      } else if (dist < 38) {
        const wt = this.add.text(b.x + b.dir * 12, b.y - 18, '!', {
          fontSize: '12px', fontFamily: 'monospace', color: '#f83800'
        }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets: wt, alpha: 0, duration: 280, onComplete: () => wt.destroy() });
        this.time.delayedCall(350, () => {
          if (!this.boss) return;
          if (Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y) < 42) {
            this.hitPlayer(this.bossPhase === 2 ? 15 : 10, b);
            this.spawnSpark(this.player.x, this.player.y - 8);
          }
        });
        b.attackCooldown = this.bossPhase === 2 ? 65 : 95;
      } else {
        b.attackCooldown = 25;
      }
    }

    b.x = Phaser.Math.Clamp(b.x, this.cameras.main.scrollX + 12, this.cameras.main.scrollX + W - 12);
    this.bossHpBar.width = 60 * Math.max(0, b.hp / b.maxHp);
  }

  updateProjectiles(dt) {
    for (const p of this.projectiles) {
      if (!p.active) continue;
      p.x += p.vx; p.y += p.vy; p.life--;
      if (p.label && p.label.active) p.label.setPosition(p.x, p.y);
      if (Phaser.Math.Distance.Between(p.x, p.y, this.player.x, this.player.y) < 14) {
        this.hitPlayer(p.fromBoss ? 10 : 5, null);
        this.stats.bubblesPopped++;
        if (p.label) p.label.destroy(); p.destroy(); continue;
      }
      if (p.life <= 0 || p.x < this.cameras.main.scrollX - 30 || p.x > this.cameras.main.scrollX + W + 30) {
        if (p.label) p.label.destroy(); p.destroy();
      }
    }
    this.projectiles = this.projectiles.filter(p => p.active);
  }

  updateDoubtClouds(dt) {
    for (const c of this.doubtClouds) {
      if (!c.active) continue;
      c.life--;
      c.setAlpha(0.3 + Math.sin(c.life * 0.1) * 0.15);
      if (c.life <= 0) c.destroy();
    }
    this.doubtClouds = this.doubtClouds.filter(c => c.active);
  }

  updateUI() {
    this.hpBar.width = 60 * Math.max(0, this.player.hp / this.player.maxHp);
    const pct = this.player.hp / this.player.maxHp;
    this.hpBar.fillColor = pct > 0.5 ? NES.green : (pct > 0.25 ? NES.yellow : NES.red);
    this.scoreText.setText(`SCORE ${this.score}`);
  }

  showEndScreen(won) {
    this.endBg.setVisible(true);
    if (won) {
      this.endText.setText(
        '★ VERIFIED! ★\n\n' +
        `Score: ${this.score}\n` +
        `Combos: ${this.stats.combos}\n` +
        `Bubbles Popped: ${this.stats.bubblesPopped}\n` +
        `Myths Bonked: ${this.stats.mythsBonked}\n\n` +
        'Press J to play again'
      ).setColor('#b8f818').setVisible(true);
    } else {
      this.endText.setText(
        'MISLED... TRY AGAIN\n\n' +
        `Score: ${this.score}\n` +
        `Myths Bonked: ${this.stats.mythsBonked}\n\n` +
        'Press J to restart'
      ).setColor('#f83800').setVisible(true);
    }
  }
}

// ============================================================
// PHASER CONFIG
// ============================================================
const SCALE = Math.min(Math.floor(window.innerWidth / W), Math.floor(window.innerHeight / H));
const game = new Phaser.Game({
  type: Phaser.AUTO,
  width: W, height: H, zoom: SCALE,
  pixelArt: true,
  backgroundColor: '#000000',
  physics: { default: 'none' },
  scene: [GameScene],
  parent: document.body,
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
});
</script>
</body>
</html>
