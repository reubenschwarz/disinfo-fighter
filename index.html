<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Disinformation Fighter</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; }
  canvas { image-rendering: pixelated; image-rendering: crisp-edges; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
<script>
// ============================================================
// CONFIG
// ============================================================
const CONFIG = {
  runDurationSeconds: 120,
  waveSchedule: [
    { time: 2,  enemies: [{ type: 'bruiser', count: 2 }] },
    { time: 12, enemies: [{ type: 'columnist', count: 2 }, { type: 'bruiser', count: 1 }] },
    { time: 22, enemies: [{ type: 'shouter', count: 2 }] },
    { time: 32, enemies: [{ type: 'bruiser', count: 1 }, { type: 'lobbyist', count: 1 }, { type: 'columnist', count: 1 }] },
    { time: 42, enemies: [{ type: 'shouter', count: 1 }, { type: 'bruiser', count: 2 }] },
    { time: 50, enemies: [{ type: 'lobbyist', count: 1 }, { type: 'columnist', count: 1 }, { type: 'shouter', count: 1 }] },
  ],
  bossSpawnTime: 60,
  enemyNames: {
    bruiser:    'Daily Tattler',
    columnist:  'The Austeralian',
    shouter:    'Faux News AU',
    lobbyist:   'Advance Aus™',
  },
  bossLinesParody: [
    "I have the best misinformation!",
    "Nobody spreads doubt like me!",
    "Tremendous confusion, believe me!",
    "I know more about hoaxes than anyone!",
    "Many people are saying… things!",
    "This is the greatest distraction ever!",
    "Fake? You're fake! Everything is fake!",
    "I alone can confuse the narrative!",
  ],
  bossLinesOptionalRealQuotes: [],
  bubbleTexts: ['DOUBT', 'HOAX', 'JUST ASKING', 'BOTH SIDES', 'SUSPICIOUS', 'FAKE', 'WAKE UP'],
  // Boss head image (Wikimedia Commons, CC-BY 4.0)
  bossHeadURL: 'https://upload.wikimedia.org/wikipedia/commons/0/0b/Vladimir_Putin_close-up_%28cropped%29.jpg',
};

// ============================================================
// CONSTANTS
// ============================================================
const W = 320, H = 180;
const LANE_TOP = 100, LANE_BOT = 170;
const GROUND_Y = 150;

// 16-bit expanded palette (SNES/Genesis style — richer gradients)
const PAL = {
  black: 0x000000, darkGrey: 0x3a3a4a, midGrey: 0x8888a0, ltGrey: 0xc8c8d8, white: 0xfcfcfc,
  // Skin tones (3-shade)
  skinDark: 0xc08060, skin: 0xe8a880, skinLight: 0xf8d0b8,
  // Hair
  hairDark: 0x302010, hair: 0x5a3820, hairLight: 0x8a5830,
  // Blues (player)
  blueDark: 0x1838a0, blue: 0x3060d8, blueLight: 0x5888f8, blueBright: 0x88b0f8,
  // Reds
  redDark: 0x881010, red: 0xd02020, redLight: 0xf04040, redBright: 0xf88080,
  // Greens
  greenDark: 0x106010, green: 0x20a030, greenLight: 0x50d060, greenBright: 0x90f0a0,
  // Oranges/brown
  brownDark: 0x503010, brown: 0x886030, brownLight: 0xb88850, tan: 0xd8b070,
  // Purples
  purpleDark: 0x481878, purple: 0x7030b0, purpleLight: 0xa058e0, purpleBright: 0xc888f8,
  // Yellows
  yellowDark: 0xa88010, yellow: 0xd8b020, yellowLight: 0xf8e060, yellowBright: 0xf8f0a0,
  // Boss military
  oliveDark: 0x2a4a10, olive: 0x3a6a18, oliveLight: 0x508a28,
  // UI
  hpGreen: 0x30d838, hpYellow: 0xe8d020, hpRed: 0xe02020, hpBg: 0x181828,
};

// ============================================================
// AUDIO ENGINE
// ============================================================
class ChipAudio {
  constructor() { this.ctx = null; this.musicGain = null; this.sfxGain = null; this.musicPlaying = false; }
  init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.musicGain = this.ctx.createGain(); this.musicGain.gain.value = 0.15; this.musicGain.connect(this.ctx.destination);
    this.sfxGain = this.ctx.createGain(); this.sfxGain.gain.value = 0.25; this.sfxGain.connect(this.ctx.destination);
  }
  resume() { if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }
  note(freq, dur, type = 'square', gain = null) {
    if (!this.ctx) return;
    const osc = this.ctx.createOscillator(), g = this.ctx.createGain();
    osc.type = type; osc.frequency.value = freq;
    g.gain.setValueAtTime(0.3, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    osc.connect(g); g.connect(gain || this.sfxGain); osc.start(); osc.stop(this.ctx.currentTime + dur);
  }
  noise(dur = 0.08) {
    if (!this.ctx) return;
    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
    const d = buf.getChannelData(0); for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const src = this.ctx.createBufferSource(); src.buffer = buf;
    const g = this.ctx.createGain(); g.gain.setValueAtTime(0.2, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
    src.connect(g); g.connect(this.sfxGain); src.start();
  }
  sfxPunch()   { this.note(180, 0.06, 'square'); this.noise(0.05); }
  sfxKick()    { this.note(120, 0.1, 'square'); this.noise(0.08); }
  sfxCombo()   { this.note(440, 0.05, 'square'); this.note(660, 0.05, 'square'); this.noise(0.04); }
  sfxCharged() { this.note(70, 0.18, 'sawtooth'); this.note(140, 0.12, 'square'); this.noise(0.12); }
  sfxBlock()   { this.note(280, 0.04, 'triangle'); }
  sfxEnemyDie(){ this.note(500, 0.04, 'square'); this.note(380, 0.06, 'square'); this.note(260, 0.1, 'triangle'); }
  sfxBossHit() { this.note(80, 0.15, 'sawtooth'); this.noise(0.12); }
  sfxWin()     { [523,659,784,1047].forEach((f,i) => setTimeout(() => this.note(f, 0.3, 'square'), i*120)); }
  sfxLose()    { [300,250,200,150].forEach((f,i) => setTimeout(() => this.note(f, 0.4, 'sawtooth'), i*180)); }
  startMusic(track = 'stage') {
    if (this.musicPlaying) this.stopMusic(); this.musicPlaying = true;
    const BPM = track === 'boss' ? 160 : 140;
    const s16 = (60 / BPM) / 4;
    const bass = track === 'boss'
      ? [55,55,0,55,65.41,0,55,0, 55,55,0,55,73.42,0,65.41,0, 49,49,0,49,55,0,65.41,55, 49,49,0,65.41,73.42,0,55,0]
      : [82.41,0,82.41,82.41,110,0,98,82.41, 82.41,0,82.41,82.41,123.47,0,110,98, 73.42,0,73.42,73.42,98,0,82.41,73.42, 82.41,0,82.41,98,110,0,123.47,110];
    const mel = track === 'boss'
      ? [440,0,440,523,587,0,523,440, 392,0,440,0,523,587,523,0, 392,0,392,440,523,0,587,523, 440,0,523,587,659,0,587,0]
      : [659,0,659,784,880,0,784,659, 587,0,659,0,784,0,659,0, 587,0,587,659,784,0,880,784, 659,0,587,0,494,0,587,0];
    const harm = [330,0,330,392,440,0,392,330, 294,0,330,0,392,0,330,0, 294,0,294,330,392,0,440,392, 330,0,294,0,247,0,294,0];
    let step = 0;
    this._musicInterval = setInterval(() => {
      if (!this.musicPlaying) return;
      const i = step % bass.length;
      if (bass[i] > 0) this.note(bass[i], s16 * 1.5, 'triangle', this.musicGain);
      if (mel[i] > 0) this.note(mel[i], s16 * 1.2, 'square', this.musicGain);
      if (track === 'stage' && harm[i] > 0) {
        const g2 = this.ctx.createGain(); g2.gain.value = 0.06; g2.connect(this.musicGain);
        this.note(harm[i], s16, 'square', g2);
      }
      if (i % 4 === 0) {
        const nb = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.04, this.ctx.sampleRate);
        const nd = nb.getChannelData(0); for (let j = 0; j < nd.length; j++) nd[j] = Math.random() * 2 - 1;
        const ns = this.ctx.createBufferSource(); ns.buffer = nb;
        const ng = this.ctx.createGain();
        ng.gain.setValueAtTime(i % 8 === 0 ? 0.12 : 0.06, this.ctx.currentTime);
        ng.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.04);
        ns.connect(ng); ng.connect(this.musicGain); ns.start();
      }
      step++;
    }, s16 * 1000);
  }
  stopMusic() { this.musicPlaying = false; if (this._musicInterval) clearInterval(this._musicInterval); }
}
const audio = new ChipAudio();

// ============================================================
// 16-BIT TEXTURE GENERATION (SNES / Streets of Rage style)
// ============================================================
function genTextures(scene) {
  // ==========================================================
  // PIXEL-MAP RENDERER — each char maps to a palette color,
  // rendered at 2×2 pixels per cell for authentic 16-bit look
  // ==========================================================
  function renderPixelMap(key, grid, palette, texW, texH) {
    const scale = 2;
    const cols = texW / scale, rows = texH / scale;
    const g = scene.make.graphics({ add: false });
    for (let r = 0; r < rows; r++) {
      const row = grid[r] || '';
      for (let c = 0; c < cols; c++) {
        const ch = row[c];
        if (!ch || ch === '.' || ch === ' ') continue;
        const color = palette[ch];
        if (color === undefined) continue;
        g.fillStyle(color);
        g.fillRect(c * scale, r * scale, scale, scale);
      }
    }
    g.generateTexture(key, texW, texH);
    g.destroy();
  }

  // ----------------------------------------------------------
  // SHARED PALETTES
  // ----------------------------------------------------------
  const skinPal = {
    'O': PAL.black,       // outline
    'S': PAL.skinDark,    // skin shadow
    's': PAL.skin,        // skin mid
    'h': PAL.skinLight,   // skin highlight
  };
  const eyePal = {
    'W': PAL.white,       // eye white
    'E': PAL.blueDark,    // iris
    'P': PAL.black,       // pupil
  };

  // ==========================================================
  // PLAYER — STAND (24×28 grid → 48×56 rendered)
  // Muscular brawler: brown hair, blue tank top, red pants,
  // brown boots, clipboard in right hand
  // ==========================================================
  const playerPal = {
    ...skinPal, ...eyePal,
    'H': PAL.hairDark,    // hair dark
    'A': PAL.hair,        // hair mid
    'a': PAL.hairLight,   // hair highlight
    'B': PAL.blueDark,    // shirt dark
    'b': PAL.blue,        // shirt mid
    'c': PAL.blueLight,   // shirt highlight
    'i': PAL.blueBright,  // shirt specular
    'R': PAL.redDark,     // pants dark
    'r': PAL.red,         // pants mid
    'e': PAL.redLight,    // pants highlight
    'D': PAL.brownDark,   // boot/belt dark
    'd': PAL.brown,       // boot mid
    'f': PAL.brownLight,  // boot highlight
    'Y': PAL.yellowDark,  // belt dark
    'y': PAL.yellow,      // belt mid
    'z': PAL.yellowLight, // belt highlight
    'Z': PAL.yellowBright,// buckle
    'w': PAL.white,       // clipboard / eye
    'g': PAL.midGrey,     // clipboard lines
    'M': PAL.darkGrey,    // mouth shadow
  };
  const playerGrid = [
    '........HAAAaaA.........',
    '.......HAaaaaaAH........',
    '......HAaaaaaaaAH.......',
    '......HAaaaaaaaAH.......',
    '.......OsshhssO.........',
    '......OsshhhhhsO........',
    '......OshhhhhhhO........',
    '......OshhhhhhhO........',
    '......OsWWEPWWEPO.......',
    '......OsWWEPWWEPO.......',
    '......OsshhhhhssO.......',
    '......OssSMMMSssO.......',
    '......OssShhhSssO.......',
    '.......OSsssssSO........',
    '..OOO..OBBbbBO..OOO....',
    '.OhsSOOBBbbbbBOOSshO...',
    '.OhssOBBcbbbcbBOsshO...',
    '.OsssOBbiibbiiBOsssO...',
    '.OsssOBBbbbbbbBOsssO...',
    '.OssSBBBbbbbbbBBSssO...',
    '.OSsSOBBbbbbbbBOSsSOwww',
    '..OSO.OYYyzZYYO.OSO.Ogw',
    '......OYYyzZYYO.....Owgw',
    '......ORrreeRrO.....Ogw',
    '......ORrreeRrO.....Owgw',
    '......ORrROORrO.....Oww',
    '......ODddOODdO........',
    '......ODffOODfO........',
  ];
  renderPixelMap('player', playerGrid, playerPal, 48, 56);

  // ==========================================================
  // PLAYER — KICK POSE (24×28 grid → 48×56 rendered)
  // Same torso, left leg planted, right leg extended
  // ==========================================================
  const playerKickGrid = [
    '........HAAAaaA.........',
    '.......HAaaaaaAH........',
    '......HAaaaaaaaAH.......',
    '......HAaaaaaaaAH.......',
    '.......OsshhssO.........',
    '......OsshhhhhsO........',
    '......OshhhhhhhO........',
    '......OshhhhhhhO........',
    '......OsWWEPWWEPO.......',
    '......OsWWEPWWEPO.......',
    '......OsshhhhhssO.......',
    '......OssSMMMSssO.......',
    '......OssShhhSssO.......',
    '.......OSsssssSO........',
    '..OOO..OBBbbBO..OOO....',
    '.OhsSOOBBbbbbBOOSshO...',
    '.OhssOBBcbbbcbBOsshO...',
    '.OsssOBbiibbiiBOsssO...',
    '.OsssOBBbbbbbbBOsssO...',
    '.OssSBBBbbbbbbBBSssO...',
    '.OSsSOBBbbbbbbBOSsSO...',
    '..OSO.OYYyzZYYO.OSO....',
    '......OYYyzZYYO........',
    '......ORrreRrrrrreO....',
    '......ORrROORrrrreO....',
    '......ORrROODddfffO....',
    '......ODddO............',
    '......ODffO............',
  ];
  renderPixelMap('player_kick', playerKickGrid, playerPal, 48, 56);

  // ==========================================================
  // ENEMY: BRUISER (18×24 grid → 36×48 rendered)
  // Bulky red-shirt enemy, broad shoulders
  // ==========================================================
  const bruiserPal = {
    ...skinPal, ...eyePal,
    'H': PAL.black,       // hair
    'R': PAL.redDark,     // shirt dark
    'r': PAL.red,         // shirt mid
    'e': PAL.redLight,    // shirt highlight
    'G': PAL.darkGrey,    // pants dark
    'g': PAL.midGrey,     // pants mid
    'D': PAL.brownDark,   // boot dark
    'd': PAL.brown,       // boot mid
    'f': PAL.brownLight,  // boot highlight
    'K': PAL.darkGrey,    // belt
  };
  const bruiserGrid = [
    '......OHHHHHO.........',
    '.....OHHHHHHHHO........',
    '.....OsshhhssO........',
    '.....OshhhhhsO........',
    '.....OWEPsWEPO........',
    '.....OssSSSssO........',
    '......OSsssSO.........',
    '..OOOORRrreeROOOO.....',
    '.OhsOORrreerrOOshO....',
    '.OssORerrrrreROssO....',
    '.OssORrrrrrrrROssO....',
    '.OssORrrrrrrrROssO....',
    '.OsSOOrrrrrrOOSsO.....',
    '.OSOO.OKKKKO..OOO.....',
    '......OGggGggO........',
    '......OGggGggO........',
    '......OGggGggO........',
    '......OGggGggO........',
    '......OGgOOGgO........',
    '......OGgOOGgO........',
    '......ODdOODdO........',
    '......OdfOOdfO........',
    '......OdfOOdfO........',
    '......OOOO.OOOO.......',
  ];
  renderPixelMap('bruiser', bruiserGrid, bruiserPal, 36, 48);

  // ==========================================================
  // ENEMY: COLUMNIST (16×24 grid → 32×48 rendered)
  // Brown suit, blue-grey pants, slimmer build
  // ==========================================================
  const columnistPal = {
    ...skinPal, ...eyePal,
    'H': PAL.black,
    'B': PAL.brownDark,   // suit dark
    'b': PAL.brown,       // suit mid
    't': PAL.tan,         // suit highlight
    'Q': 0x183848,        // pants dark
    'q': 0x2a5a6a,        // pants mid
    'D': PAL.brownDark,
    'd': PAL.brown,
    'f': PAL.brownLight,
    'K': PAL.darkGrey,
    'w': PAL.white,       // shirt collar
  };
  const columnistGrid = [
    '.....OHHHHHHO........',
    '....OHHHHHHHO........',
    '....OsshhhssO........',
    '....OshhhhhsO........',
    '....OWEPSWEPPO.......',
    '....OssSSSssO........',
    '.....OSsssSO.........',
    '...OOOwBbtOOOOO......',
    '..OhsOBbbtbbOshO.....',
    '..OssOBbbtbbOssO.....',
    '..OssOBbbbbBOssO.....',
    '..OsSOBbbbbBOSsO.....',
    '..OSO.OKKKKO.OSO.....',
    '......OQqqQqO........',
    '......OQqqQqO........',
    '......OQqqQqO........',
    '......OQqqQqO........',
    '......OQqOOQqO.......',
    '......OQqOOQqO.......',
    '......ODdOODdO.......',
    '......ODdOODdO.......',
    '......OdfOOdfO.......',
    '......OOOO.OOOO......',
    '........................',
  ];
  renderPixelMap('columnist', columnistGrid, columnistPal, 32, 48);

  // ==========================================================
  // ENEMY: SHOUTER (16×24 grid → 32×48 rendered)
  // Purple outfit, dark pants, aggressive stance
  // ==========================================================
  const shouterPal = {
    ...skinPal, ...eyePal,
    'H': PAL.black,
    'V': PAL.purpleDark,  // shirt dark
    'v': PAL.purple,      // shirt mid
    'p': PAL.purpleLight, // shirt highlight
    'G': PAL.darkGrey,    // pants dark
    'g': PAL.midGrey,     // pants mid
    'D': PAL.brownDark,
    'd': PAL.brown,
    'f': PAL.brownLight,
    'K': PAL.darkGrey,
  };
  const shouterGrid = [
    '.....OHHHHHHO........',
    '....OHHHHHHHO........',
    '....OsshhhssO........',
    '....OshhhhhsO........',
    '....OWEPSWEPPO.......',
    '....OssOOOOssO.......',
    '.....OSsssSO.........',
    '...OOOVVvppOOOO......',
    '..OhsOVvvppvOshO.....',
    '..OssOVvvvvvOssO.....',
    '..OssOVvvvvvOssO.....',
    '..OsSOOvvvvOOSsO.....',
    '..OSO.OKKKKO.OSO.....',
    '......OGggGgO........',
    '......OGggGgO........',
    '......OGggGgO........',
    '......OGggGgO........',
    '......OGgOOGgO.......',
    '......OGgOOGgO.......',
    '......ODdOODdO.......',
    '......ODdOODdO.......',
    '......OdfOOdfO.......',
    '......OOOO.OOOO......',
    '........................',
  ];
  renderPixelMap('shouter', shouterGrid, shouterPal, 32, 48);

  // ==========================================================
  // ENEMY: LOBBYIST (16×24 grid → 32×48 rendered)
  // Green suit, brown pants, business attire
  // ==========================================================
  const lobbyistPal = {
    ...skinPal, ...eyePal,
    'H': PAL.black,
    'L': PAL.greenDark,   // suit dark
    'l': PAL.green,       // suit mid
    'n': PAL.greenLight,  // suit highlight
    'B': PAL.brownDark,   // pants dark
    'b': PAL.brown,       // pants mid
    'D': PAL.brownDark,
    'd': PAL.brown,
    'f': PAL.brownLight,
    'K': PAL.darkGrey,
    'w': PAL.white,       // shirt collar
  };
  const lobbyistGrid = [
    '.....OHHHHHHO........',
    '....OHHHHHHHO........',
    '....OsshhhssO........',
    '....OshhhhhsO........',
    '....OWEPSWEPPO.......',
    '....OssSSSssO........',
    '.....OSsssSO.........',
    '...OOOwLlnOOOOO......',
    '..OhsOLllnllOshO.....',
    '..OssOLllnllOssO.....',
    '..OssOLllllLOssO.....',
    '..OsSOOllllOOSsO.....',
    '..OSO.OKKKKO.OSO.....',
    '......OBbbBbO........',
    '......OBbbBbO........',
    '......OBbbBbO........',
    '......OBbbBbO........',
    '......OBbOOBbO.......',
    '......OBbOOBbO.......',
    '......ODdOODdO.......',
    '......ODdOODdO.......',
    '......OdfOOdfO.......',
    '......OOOO.OOOO......',
    '........................',
  ];
  renderPixelMap('lobbyist', lobbyistGrid, lobbyistPal, 32, 48);

  // ==========================================================
  // BOSS BODY (24×27 grid → 48×54 rendered)
  // Military jacket with medals, olive uniform, no head
  // (photo head overlaid at runtime)
  // ==========================================================
  const bossPal = {
    ...skinPal,
    'V': PAL.oliveDark,   // jacket dark
    'v': PAL.olive,       // jacket mid
    'n': PAL.oliveLight,  // jacket highlight
    'Y': PAL.yellowDark,  // epaulette dark
    'y': PAL.yellow,      // epaulette mid / medal gold
    'z': PAL.yellowLight, // belt buckle
    'R': PAL.redDark,     // medal red dark
    'r': PAL.red,         // medal red
    'w': PAL.white,       // medal white
    'D': PAL.brownDark,   // belt dark
    'd': PAL.brown,       // belt mid
    'f': PAL.brownLight,  // belt highlight
    'G': PAL.darkGrey,    // pants dark
    'g': PAL.midGrey,     // pants mid
    'K': PAL.black,       // boot
    'k': 0x1a1a1a,        // boot mid
    'j': 0x2a2a2a,        // boot highlight
  };
  const bossGrid = [
    '........OssssssO........',
    '........OssssssO........',
    '........OssssssO........',
    '...OYyOOVVvvnnVOOyYO...',
    '...OYyOVVvvnnvvVOyYO...',
    '..OVvOVyyvvnnvvVOvVO...',
    '..OVvOVyyvvvvvvVOvVO...',
    '..OVvOVrrvvvvvvVOvVO...',
    '..OVvOVrrVvwvvVVOvVO...',
    '..OvnOVVvvvvvvVVOnvO...',
    '..OvnOVVvvvvvvVVOnvO...',
    '..OssO.VVvvnnVV..OssO..',
    '..OssO.VVvvnnVV..OssO..',
    '........ODddzDO........',
    '........ODddzDO........',
    '.......OGggOOggGO......',
    '.......OGggOOggGO......',
    '.......OGggOOggGO......',
    '.......OGggOOggGO......',
    '.......OGggOOggGO......',
    '.......OGggOOggGO......',
    '.......OGgOOOOgGO......',
    '.......OGgOOOOgGO......',
    '.......OKkkOOKkkO......',
    '.......OKjkOOKjkO......',
    '.......OKjkOOKjkO......',
    '.......OOOO.OOOOO......',
  ];
  renderPixelMap('boss_body', bossGrid, bossPal, 48, 54);

  // --- Projectile bubble ---
  const pb = scene.make.graphics({ add: false });
  pb.fillStyle(PAL.white); pb.fillRoundedRect(0, 0, 32, 14, 5);
  pb.fillStyle(PAL.ltGrey); pb.fillRoundedRect(1, 1, 30, 12, 4);
  pb.fillStyle(PAL.white); pb.fillRoundedRect(2, 2, 28, 10, 3);
  pb.generateTexture('bubble', 32, 14);
  pb.destroy();

  // --- Doubt cloud ---
  const dc = scene.make.graphics({ add: false });
  dc.fillStyle(0x556688); dc.fillCircle(24, 20, 20); dc.fillCircle(40, 16, 16);
  dc.fillCircle(12, 16, 14); dc.fillCircle(32, 10, 12);
  dc.generateTexture('doubtcloud', 56, 40);
  dc.destroy();

  // --- Hit spark (16-bit style — multi-colour starburst) ---
  const sp = scene.make.graphics({ add: false });
  sp.fillStyle(PAL.white); sp.fillRect(7, 0, 2, 16); sp.fillRect(0, 7, 16, 2);
  sp.fillStyle(PAL.yellowLight); sp.fillRect(6, 1, 4, 3); sp.fillRect(6, 12, 4, 3);
  sp.fillRect(1, 6, 3, 4); sp.fillRect(12, 6, 3, 4);
  sp.fillStyle(PAL.yellowDark); sp.fillRect(2, 2, 3, 3); sp.fillRect(11, 11, 3, 3);
  sp.fillRect(11, 2, 3, 3); sp.fillRect(2, 11, 3, 3);
  sp.fillStyle(PAL.red); sp.fillRect(7, 7, 2, 2);
  sp.generateTexture('spark', 16, 16);
  sp.destroy();

  // --- Confetti ---
  const cf = scene.make.graphics({ add: false });
  cf.fillStyle(PAL.yellow); cf.fillRect(0, 0, 4, 4);
  cf.generateTexture('confetti', 4, 4);
  cf.destroy();
}

// ============================================================
// ENEMY LOGO BADGE
// ============================================================
function createLogoBadge(scene, x, y, type) {
  const name = CONFIG.enemyNames[type] || type;
  const bgColors = { bruiser: '#cc2222', columnist: '#cc8800', shouter: '#8822aa', lobbyist: '#228822' };
  return scene.add.text(x, y, ` ${name} `, {
    fontSize: '7px', fontFamily: 'Arial, Helvetica, sans-serif', fontStyle: 'bold',
    color: '#ffffff', backgroundColor: bgColors[type] || '#444444', padding: { x: 3, y: 2 },
  }).setOrigin(0.5).setDepth(30);
}

// ============================================================
// MAIN SCENE
// ============================================================
class GameScene extends Phaser.Scene {
  constructor() { super('GameScene'); }

  preload() {
    // Load Putin head photo (crossOrigin handled by Phaser)
    this.load.image('putin_head', CONFIG.bossHeadURL);
    this.load.on('loaderror', () => { this._bossHeadFailed = true; });
  }

  create() {
    this.gameState = 'title';
    this.gameTime = 0; this.score = 0;
    this.stats = { combos: 0, bubblesPopped: 0, mythsBonked: 0 };
    this.waveIndex = 0; this.enemies = []; this.projectiles = []; this.doubtClouds = [];
    this.tutorialTimer = 0; this.shakeTimer = 0; this.cameraOffsetX = 0;

    genTextures(this);
    audio.init();
    this.drawBackground();
    this.player = this.createPlayer();
    this.createUI();

    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys = {
      w: this.input.keyboard.addKey('W'), a: this.input.keyboard.addKey('A'),
      s: this.input.keyboard.addKey('S'), d: this.input.keyboard.addKey('D'),
      j: this.input.keyboard.addKey('J'), k: this.input.keyboard.addKey('K'),
      l: this.input.keyboard.addKey('L'),
      shift: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT),
    };

    this.attackTimer = 0; this.comboCount = 0; this.comboWindow = 0;
    this.chargeTimer = 0; this.isCharging = false; this.isBlocking = false;
    this.attackCooldown = 0; this.playerHitCooldown = 0;
    this.jumpVel = 0; this.isJumping = false; this.playerBaseY = GROUND_Y;
    this.isMoving = false; // track horizontal movement

    this.boss = null; this.bossShoutTimer = 0; this.bossShoutText = null;
    this.bossAttackTimer = 0; this.bossPhase = 1; this.bossHead = null;

    // Title screen
    this.titleBg = this.add.rectangle(W / 2, H / 2, W, H, PAL.black).setDepth(99);
    this.titleText = this.add.text(W / 2, 30, 'DISINFORMATION\n      FIGHTER', {
      fontSize: '16px', fontFamily: 'monospace', color: '#f04040', align: 'center',
      stroke: '#401010', strokeThickness: 3
    }).setOrigin(0.5).setDepth(100);
    this.titleSub = this.add.text(W / 2, 80, '— FIGHT MISINFORMATION —', {
      fontSize: '7px', fontFamily: 'monospace', color: '#f8e060'
    }).setOrigin(0.5).setDepth(100);
    this.titleStart = this.add.text(W / 2, 115, 'PRESS  J  TO START', {
      fontSize: '8px', fontFamily: 'monospace', color: '#fcfcfc'
    }).setOrigin(0.5).setDepth(100);
    this.titleCredits = this.add.text(W / 2, 150, '© 2026 FACT-CHECKER STUDIOS', {
      fontSize: '5px', fontFamily: 'monospace', color: '#606080'
    }).setOrigin(0.5).setDepth(100);
    this.titleFlash = 0;

    this.tutorialBg = this.add.rectangle(W/2, H/2, W-16, H-16, 0x000000, 0.92).setDepth(90).setVisible(false).setScrollFactor(0);
    this.tutorialText = this.add.text(W/2, H/2, '', {
      fontSize: '7px', fontFamily: 'monospace', color: '#f8e060', align: 'center', lineSpacing: 5
    }).setOrigin(0.5).setDepth(91).setVisible(false).setScrollFactor(0);
    this.endBg = this.add.rectangle(W/2, H/2, W, H, 0x000000, 0.92).setDepth(100).setVisible(false).setScrollFactor(0);
    this.endText = this.add.text(W/2, H/2, '', {
      fontSize: '8px', fontFamily: 'monospace', color: '#ffffff', align: 'center', lineSpacing: 5
    }).setOrigin(0.5).setDepth(101).setVisible(false).setScrollFactor(0);
  }

  // --- 16-BIT BACKGROUND ---
  drawBackground() {
    // Gradient night sky
    for (let i = 0; i < 100; i++) {
      const t = i / 100;
      const r = Math.floor(8 + t * 15), g = Math.floor(6 + t * 10), b = Math.floor(30 + t * 25);
      this.add.rectangle(W * 2.5, i, W * 8, 1, Phaser.Display.Color.GetColor(r, g, b)).setDepth(-10).setScrollFactor(0.05);
    }
    // Stars (twinkling via different sizes)
    for (let i = 0; i < 40; i++) {
      const s = Math.random() > 0.7 ? 2 : 1;
      this.add.rectangle(Math.random() * W * 6, 3 + Math.random() * 45, s, s, PAL.white)
        .setDepth(-9).setScrollFactor(0.05).setAlpha(0.5 + Math.random() * 0.5);
    }
    // Distant city silhouettes (far parallax)
    for (let i = 0; i < 35; i++) {
      const bw = 18 + Math.random() * 30, bh = 20 + Math.random() * 40;
      this.add.rectangle(i * 50, 95 - bh/2, bw, bh, 0x0c1028).setDepth(-8).setScrollFactor(0.12);
      // Tiny lit windows on distant buildings
      for (let wy = 4; wy < bh - 6; wy += 8) {
        for (let wx = 3; wx < bw - 3; wx += 6) {
          if (Math.random() > 0.5)
            this.add.rectangle(i*50 - bw/2 + wx, 95 - bh + wy + 2, 2, 3, 0xf8d060)
              .setDepth(-7).setScrollFactor(0.12).setAlpha(0.6);
        }
      }
    }
    // Brick buildings (mid-ground, detailed)
    for (let i = 0; i < 28; i++) {
      const bw = 30 + Math.random() * 40, bh = 40 + Math.random() * 50;
      const bx = i * 60 - 30;
      const wc = [0x7c3828, 0x6c3020, 0x5c2818, 0x8c4030][Math.floor(Math.random() * 4)];
      this.add.rectangle(bx, LANE_TOP - bh/2 + 8, bw, bh, wc).setDepth(-6).setScrollFactor(0.35);
      // Bricks (offset pattern)
      for (let row = 0; row < bh - 4; row += 6) {
        const off = (Math.floor(row / 6) % 2) * 5;
        for (let col = off; col < bw - 2; col += 10) {
          this.add.rectangle(bx - bw/2 + col + 4, LANE_TOP - bh + 8 + row + 5, 8, 4, wc + 0x0a0a0a)
            .setDepth(-5).setScrollFactor(0.35);
          // Mortar lines
          this.add.rectangle(bx - bw/2 + col + 4, LANE_TOP - bh + 8 + row + 2, 8, 1, wc - 0x0a0a0a)
            .setDepth(-5).setScrollFactor(0.35);
        }
      }
      // Windows (16-bit: glass reflection effect)
      for (let wy = 0; wy < bh - 14; wy += 14) {
        for (let wx = 6; wx < bw - 6; wx += 12) {
          const lit = Math.random() > 0.3;
          const wx2 = bx - bw/2 + wx + 4, wy2 = LANE_TOP - bh + 8 + wy + 8;
          this.add.rectangle(wx2, wy2, 7, 8, lit ? 0xf8d060 : 0x201818).setDepth(-4).setScrollFactor(0.35);
          if (lit) this.add.rectangle(wx2 - 1, wy2 - 2, 2, 3, 0xf8f0a0).setDepth(-4).setScrollFactor(0.35); // highlight
        }
      }
    }
    // Neon signs (16-bit staple)
    const signs = ['BAR', 'DINER', 'NEWS', 'HOTEL', '24H'];
    for (let i = 0; i < 5; i++) {
      this.add.text(80 + i * 280, LANE_TOP - 20, signs[i], {
        fontSize: '6px', fontFamily: 'monospace', color: i % 2 === 0 ? '#ff4488' : '#44ff88',
        stroke: '#000000', strokeThickness: 1
      }).setDepth(-3).setScrollFactor(0.35);
    }
    // Street
    this.add.rectangle(W * 3, LANE_TOP + 40, W * 8, 90, 0x3a3a48).setDepth(-3).setScrollFactor(1);
    // Sidewalk/kerb
    this.add.rectangle(W * 3, LANE_TOP + 2, W * 8, 5, 0x686878).setDepth(-2).setScrollFactor(1);
    this.add.rectangle(W * 3, LANE_TOP + 5, W * 8, 2, 0x585868).setDepth(-2).setScrollFactor(1);
    // Road markings
    for (let i = 0; i < 60; i++) {
      this.add.rectangle(i * 35, GROUND_Y + 10, 14, 2, 0x707048).setDepth(-1).setScrollFactor(1);
    }
    // Props
    for (let i = 0; i < 12; i++) {
      const px = 80 + i * 120 + Math.random() * 40, py = LANE_TOP + 8 + Math.random() * 8;
      if (Math.random() > 0.5) {
        sRect16(this, px-4, py-6, 8, 12, 0x505050, 0x686868, 0x808080);
        this.add.rectangle(px, py - 7, 10, 2, 0x787878).setDepth(-1).setScrollFactor(1);
      } else {
        sRect16(this, px-5, py-5, 10, 10, 0x6c4c20, 0x8c6c30, 0xa88840);
        this.add.rectangle(px, py, 8, 1, 0x504020).setDepth(-1).setScrollFactor(1);
      }
    }
  }

  createPlayer() {
    const p = this.add.sprite(40, GROUND_Y, 'player').setDepth(10);
    p.hp = 100; p.maxHp = 100; p.damageMult = 1;
    return p;
  }

  createUI() {
    this.add.rectangle(4, 3, 64, 9, PAL.black).setOrigin(0).setScrollFactor(0).setDepth(50);
    this.hpBar = this.add.rectangle(5, 4, 62, 7, PAL.hpGreen).setOrigin(0).setScrollFactor(0).setDepth(51);
    this.hpLabel = this.add.text(5, 14, 'FACT-CHECKER', {
      fontSize: '5px', fontFamily: 'monospace', color: '#5888f8'
    }).setScrollFactor(0).setDepth(51);
    this.bossHpBg = this.add.rectangle(W-68, 3, 64, 9, PAL.black).setOrigin(0).setScrollFactor(0).setDepth(50).setVisible(false);
    this.bossHpBar = this.add.rectangle(W-67, 4, 62, 7, PAL.hpRed).setOrigin(0).setScrollFactor(0).setDepth(51).setVisible(false);
    this.bossHpLabel = this.add.text(W-67, 14, '', {
      fontSize: '5px', fontFamily: 'monospace', color: '#f04040'
    }).setScrollFactor(0).setDepth(51).setVisible(false);
    this.add.text(W/2, 2, 'DISINFORMATION FIGHTER', {
      fontSize: '5px', fontFamily: 'monospace', color: '#f04040'
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);
    this.scoreText = this.add.text(W/2, 9, 'SCORE 0', {
      fontSize: '6px', fontFamily: 'monospace', color: '#fcfcfc'
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);
    this.timerText = this.add.text(W/2, 17, '', {
      fontSize: '5px', fontFamily: 'monospace', color: '#c8c8d8'
    }).setOrigin(0.5, 0).setScrollFactor(0).setDepth(51);
  }

  spawnEnemy(type, x, y) {
    const e = this.add.sprite(x, y, type).setDepth(9);
    e.enemyType = type; e.hp = type === 'bruiser' ? 30 : 20; e.maxHp = e.hp;
    e.speed = type === 'bruiser' ? 0.7 : type === 'shouter' ? 0.35 : 0.45;
    e.attackCooldown = 0; e.attackRange = type === 'shouter' ? 100 : type === 'columnist' ? 50 : 24;
    e.stunTimer = 0; e.hitTimer = 0; e.dir = -1;
    e.logoBadge = createLogoBadge(this, x, y - 28, type);
    e.hpBg = this.add.rectangle(x - 12, y - 20, 24, 3, PAL.black).setDepth(29);
    e.hpFill = this.add.rectangle(x - 12, y - 20, 24, 3, PAL.hpRed).setOrigin(0, 0.5).setDepth(29);
    this.enemies.push(e);
    return e;
  }
  spawnWave(w) {
    const cx = this.cameras.main.scrollX;
    w.enemies.forEach(eg => { for (let i = 0; i < eg.count; i++)
      this.spawnEnemy(eg.type, cx + W + 20 + Math.random() * 50, LANE_TOP + 25 + Math.random() * (LANE_BOT - LANE_TOP - 25));
    });
  }

  // --- BOSS (with photo head) ---
  spawnBoss() {
    const cx = this.cameras.main.scrollX;
    this.boss = this.add.sprite(cx + W - 40, GROUND_Y - 5, 'boss_body').setDepth(10);
    this.boss.hp = 100; this.boss.maxHp = 100; this.boss.stunTimer = 0; this.boss.hitTimer = 0;
    this.boss.attackCooldown = 60; this.boss.dir = -1; this.boss.dashTimer = 0;
    this.bossPhase = 1; this.bossShoutTimer = 0;

    // Photo head (loaded in preload)
    if (this.textures.exists('putin_head') && !this._bossHeadFailed) {
      this.bossHead = this.add.image(this.boss.x, this.boss.y - 30, 'putin_head').setDepth(11);
      // Scale the photo down to fit as a head (~20x24 px)
      const tex = this.textures.get('putin_head').getSourceImage();
      const scale = 22 / Math.max(tex.width, tex.height);
      this.bossHead.setScale(scale);
    } else {
      // Fallback: pixel head
      this.bossHead = this.add.rectangle(this.boss.x, this.boss.y - 26, 16, 16, PAL.skin).setDepth(11);
    }

    this.bossHpBg.setVisible(true); this.bossHpBar.setVisible(true);
    this.bossHpLabel.setText('VLAD IMPUDENT').setVisible(true);
    this.bossShoutText = this.add.text(this.boss.x, this.boss.y - 44, '', {
      fontSize: '6px', fontFamily: 'monospace', color: '#f8e060', backgroundColor: '#200000dd',
      padding: { x: 3, y: 2 }, wordWrap: { width: 100 }
    }).setOrigin(0.5).setDepth(20);
    this.showBossShout();
    audio.stopMusic(); audio.startMusic('boss');
  }

  getBossLines() {
    const l = [...CONFIG.bossLinesParody];
    if (CONFIG.bossLinesOptionalRealQuotes.length > 0) l.push(...CONFIG.bossLinesOptionalRealQuotes);
    return l;
  }
  showBossShout() {
    if (!this.boss || !this.bossShoutText) return;
    const l = this.getBossLines();
    this.bossShoutText.setText(l[Math.floor(Math.random() * l.length)]);
    this.bossShoutTimer = 480;
  }

  spawnProjectile(x, y, vx, vy, fromBoss = false) {
    const p = this.add.sprite(x, y, 'bubble').setDepth(11);
    p.vx = vx; p.vy = vy; p.fromBoss = fromBoss; p.life = 300;
    p.label = this.add.text(x, y, CONFIG.bubbleTexts[Math.floor(Math.random() * CONFIG.bubbleTexts.length)], {
      fontSize: '5px', fontFamily: 'monospace', color: '#200000', fontStyle: 'bold'
    }).setOrigin(0.5).setDepth(12);
    this.projectiles.push(p);
  }
  spawnDoubtCloud(x, y) { const c = this.add.sprite(x, y, 'doubtcloud').setDepth(8).setAlpha(0.5); c.life = 300; this.doubtClouds.push(c); }
  spawnSpark(x, y) {
    const s = this.add.sprite(x, y, 'spark').setDepth(15);
    this.tweens.add({ targets: s, alpha: 0, scaleX: 2, scaleY: 2, duration: 200, onComplete: () => s.destroy() });
  }
  spawnConfetti(x, y) {
    for (let i = 0; i < 12; i++) {
      const c = this.add.sprite(x, y, 'confetti').setDepth(15).setTint(
        [PAL.red, PAL.green, PAL.blue, PAL.yellow, PAL.purpleLight][Math.floor(Math.random() * 5)]
      );
      this.tweens.add({ targets: c, x: x + (Math.random()-0.5)*60, y: y-20-Math.random()*40,
        alpha: 0, duration: 600+Math.random()*300, onComplete: () => c.destroy() });
    }
  }
  getPlayerDamage(base) {
    let d = base * this.player.damageMult;
    for (const c of this.doubtClouds) if (c.active && Phaser.Math.Distance.Between(this.player.x, this.player.y, c.x, c.y) < 35) { d *= 0.5; break; }
    return Math.max(1, Math.floor(d));
  }

  // --- UPDATE ---
  update(time, delta) {
    const dt = delta / 1000;
    if (this.shakeTimer > 0) { this.shakeTimer--; this.cameras.main.setScroll(this.cameras.main.scrollX + (Math.random()-0.5)*2, (Math.random()-0.5)*2); }

    if (this.gameState === 'title') {
      this.titleFlash += dt;
      this.titleStart.setAlpha(Math.sin(this.titleFlash * 3) * 0.5 + 0.5);
      if (Phaser.Input.Keyboard.JustDown(this.keys.j)) {
        audio.resume();
        [this.titleBg, this.titleText, this.titleSub, this.titleStart, this.titleCredits].forEach(t => t.setVisible(false));
        this.gameState = 'tutorial'; this.tutorialTimer = 420; this.showTutorial(); audio.startMusic('stage');
      }
      return;
    }
    if (this.gameState === 'tutorial') {
      this.tutorialTimer--;
      if (this.tutorialTimer <= 0) { this.tutorialBg.setVisible(false); this.tutorialText.setVisible(false); this.gameState = 'playing'; }
      this.updatePlayer(dt); return;
    }
    if (this.gameState === 'win' || this.gameState === 'lose') {
      if (Phaser.Input.Keyboard.JustDown(this.keys.j)) this.scene.restart(); return;
    }

    this.gameTime += dt;
    this.timerText.setText(`${Math.floor(this.gameTime/60)}:${Math.floor(this.gameTime%60).toString().padStart(2,'0')}`);

    if (this.gameState === 'playing') {
      if (this.waveIndex < CONFIG.waveSchedule.length) {
        const w = CONFIG.waveSchedule[this.waveIndex];
        if (this.gameTime >= w.time) { this.spawnWave(w); this.waveIndex++; }
      }
      if (this.gameTime < CONFIG.bossSpawnTime) { this.cameraOffsetX += 0.4; this.cameras.main.scrollX = this.cameraOffsetX; }
      const allDone = this.waveIndex >= CONFIG.waveSchedule.length;
      const noEn = this.enemies.filter(e => e.active).length === 0;
      if ((this.gameTime >= CONFIG.bossSpawnTime && noEn) || (allDone && noEn && this.gameTime > 45)) {
        this.gameState = 'bossIntro'; this.bossIntroTimer = 120;
        this.bossIntroText = this.add.text(W/2, H/2-15, 'WARNING!!\n\nVLADIMIR IMPUDENT\n    APPROACHES!', {
          fontSize: '9px', fontFamily: 'monospace', color: '#f04040', align: 'center', stroke: '#000000', strokeThickness: 2
        }).setOrigin(0.5).setScrollFactor(0).setDepth(80);
      }
    }
    if (this.gameState === 'bossIntro') {
      this.bossIntroTimer--; this.updatePlayer(dt);
      if (this.bossIntroTimer <= 0) { this.bossIntroText.destroy(); this.gameState = 'bossFight'; this.spawnBoss(); }
      return;
    }

    this.updatePlayer(dt); this.updateEnemies(dt); this.updateBoss(dt);
    this.updateProjectiles(dt); this.updateDoubtClouds(dt); this.updateUI();
    if (this.player.hp <= 0 && this.gameState !== 'lose') {
      this.gameState = 'lose'; audio.stopMusic(); audio.sfxLose(); this.showEndScreen(false);
    }
  }

  showTutorial() {
    this.tutorialBg.setVisible(true);
    this.tutorialText.setText(
      '— CONTROLS —\n\nMOVE:   Arrows / WASD\nJUMP:   K\nATTACK: J  (tap-tap = combo)\n' +
      '        Hold J = charged hit\n        Jump+J = KICK!\nBLOCK:  L or Shift\n\nDefeat the waves! Pop bubbles.'
    ).setVisible(true);
  }

  // --- PLAYER ---
  updatePlayer(dt) {
    const p = this.player, spd = 1.6;
    let mx = 0, my = 0;
    if (this.cursors.left.isDown || this.keys.a.isDown) mx = -1;
    if (this.cursors.right.isDown || this.keys.d.isDown) mx = 1;
    if (this.cursors.up.isDown || this.keys.w.isDown) my = -1;
    if (this.cursors.down.isDown || this.keys.s.isDown) my = 1;
    this.isMoving = mx !== 0 || my !== 0;

    if (!this.isBlocking) {
      p.x += mx * spd;
      this.playerBaseY = Phaser.Math.Clamp(this.playerBaseY + my * spd * 0.7, LANE_TOP + 15, LANE_BOT);
    }
    p.x = Phaser.Math.Clamp(p.x, this.cameras.main.scrollX + 12, this.cameras.main.scrollX + W - 12);
    if (mx !== 0) p.setFlipX(mx < 0);

    if (Phaser.Input.Keyboard.JustDown(this.keys.k) && !this.isJumping) { this.isJumping = true; this.jumpVel = -4.5; }
    if (this.isJumping) {
      this.jumpVel += 0.22; p.y += this.jumpVel;
      if (p.y >= this.playerBaseY) { p.y = this.playerBaseY; this.isJumping = false; this.jumpVel = 0; p.setTexture('player'); }
    } else { p.y = this.playerBaseY; }

    this.isBlocking = this.keys.l.isDown || this.keys.shift.isDown;
    if (this.isBlocking) p.setTint(PAL.blueLight);
    else if (!this.isCharging) p.clearTint();

    if (this.attackCooldown > 0) this.attackCooldown--;
    if (this.comboWindow > 0) this.comboWindow--;
    if (this.playerHitCooldown > 0) this.playerHitCooldown--;

    if (this.keys.j.isDown && !this.isBlocking) {
      this.chargeTimer++;
      if (this.chargeTimer > 30) { this.isCharging = true; p.setTint(PAL.yellowLight); }
    }

    if (Phaser.Input.Keyboard.JustUp(this.keys.j) && this.attackCooldown <= 0 && !this.isBlocking) {
      const isKick = this.isJumping;
      if (isKick) {
        // JUMP KICK — more damage, extended range
        p.setTexture('player_kick');
        this.performAttack(20, 30, false, true);
        audio.sfxKick();
      } else if (this.isCharging && this.chargeTimer > 30) {
        this.performAttack(25, 28, true, false); audio.sfxCharged(); this.isCharging = false;
      } else if (this.comboWindow > 0 && this.comboCount >= 1) {
        this.performAttack(15, 22, false, false); this.comboCount++;
        if (this.comboCount >= 3) { this.stats.combos++; this.spawnConfetti(p.x + (p.flipX?-15:15), p.y-8); audio.sfxCombo(); this.comboCount = 0; }
        else audio.sfxPunch();
      } else {
        this.performAttack(8, 20, false, false); this.comboCount = 1; audio.sfxPunch();
      }
      this.comboWindow = 30; this.attackCooldown = 12; this.chargeTimer = 0;
    }
    if (Phaser.Input.Keyboard.JustDown(this.keys.j)) { this.chargeTimer = 0; this.isCharging = false; }
    p.setDepth(10 + (p.y / H) * 0.1);
  }

  performAttack(damage, range, isCharged, isKick) {
    const p = this.player, dir = p.flipX ? -1 : 1;
    const ax = p.x + dir * range / 2, ay = p.y;
    this.spawnSpark(p.x + dir * (isKick ? 20 : 14), p.y - (isKick ? 2 : 8));

    for (const e of this.enemies) {
      if (!e.active) continue;
      if (Phaser.Math.Distance.Between(ax, ay, e.x, e.y) < range) {
        e.hp -= this.getPlayerDamage(damage); e.hitTimer = 10;
        e.x += dir * (isCharged ? 14 : isKick ? 10 : 6); e.setTint(PAL.white);
        this.stats.mythsBonked++;
        if (e.hp <= 0) this.killEnemy(e);
      }
    }
    if (this.boss && this.boss.active && Phaser.Math.Distance.Between(ax, ay, this.boss.x, this.boss.y) < range + 12) {
      this.boss.hp -= this.getPlayerDamage(damage); this.boss.hitTimer = 10;
      this.boss.x += dir * (isCharged ? 8 : 4); this.boss.setTint(PAL.white);
      audio.sfxBossHit(); this.shakeTimer = isCharged ? 8 : 3;
      if (this.boss.hp <= this.boss.maxHp * 0.4 && this.bossPhase === 1) { this.bossPhase = 2; this.showBossShout(); }
      if (this.boss.hp <= 0) {
        this.boss.destroy(); if (this.bossHead) this.bossHead.destroy();
        if (this.bossShoutText) this.bossShoutText.destroy();
        this.bossHpBg.setVisible(false); this.bossHpBar.setVisible(false); this.bossHpLabel.setVisible(false);
        this.boss = null; this.gameState = 'win'; audio.stopMusic(); audio.sfxWin();
        this.shakeTimer = 15;
        this.spawnConfetti(p.x, p.y-10); this.spawnConfetti(p.x+20, p.y); this.spawnConfetti(p.x-20, p.y);
        this.showEndScreen(true);
      }
    }
    for (const pr of this.projectiles) {
      if (!pr.active) continue;
      if (Phaser.Math.Distance.Between(ax, ay, pr.x, pr.y) < range) { pr.label.destroy(); pr.destroy(); this.stats.bubblesPopped++; this.score += 50; }
    }
  }

  killEnemy(e) {
    audio.sfxEnemyDie(); this.score += 100; this.spawnSpark(e.x, e.y-8);
    if (e.logoBadge) e.logoBadge.destroy(); if (e.hpBg) e.hpBg.destroy(); if (e.hpFill) e.hpFill.destroy();
    e.destroy();
  }

  updateEnemies(dt) {
    for (const e of this.enemies) {
      if (!e.active) continue;
      if (e.hitTimer > 0) { e.hitTimer--; if (e.hitTimer <= 0) e.clearTint(); }
      if (e.stunTimer > 0) { e.stunTimer--; continue; }
      if (e.attackCooldown > 0) e.attackCooldown--;
      const dx = this.player.x - e.x, dy = this.player.y - e.y, dist = Math.sqrt(dx*dx+dy*dy);
      e.dir = dx > 0 ? 1 : -1; e.setFlipX(e.dir < 0);
      if (dist > e.attackRange) { e.x += (dx/dist)*e.speed; e.y += (dy/dist)*e.speed*0.5; e.y = Phaser.Math.Clamp(e.y, LANE_TOP+10, LANE_BOT); }
      if (dist <= e.attackRange + 5 && e.attackCooldown <= 0) this.enemyAttack(e);
      if (e.logoBadge && e.logoBadge.active) e.logoBadge.setPosition(e.x, e.y - 28);
      if (e.hpBg && e.hpBg.active) { e.hpBg.setPosition(e.x, e.y-20); e.hpFill.setPosition(e.x-12, e.y-20); e.hpFill.width = 24*Math.max(0, e.hp/e.maxHp); }
      e.setDepth(10 + (e.y/H)*0.1);
    }
    this.enemies = this.enemies.filter(e => e.active);
  }
  enemyAttack(e) {
    if (e.enemyType === 'bruiser') { e.x += e.dir*10; this.hitPlayer(8); e.attackCooldown = 80; }
    else if (e.enemyType === 'columnist') {
      this.hitPlayer(5);
      const ht = this.add.text(e.x+e.dir*12, e.y-22, 'HOT TAKE!', { fontSize:'6px', fontFamily:'monospace', color:'#f8e060', backgroundColor:'#000000cc', padding:{x:2,y:1} }).setOrigin(0.5).setDepth(20);
      this.tweens.add({ targets:ht, alpha:0, y:e.y-40, duration:700, onComplete:()=>ht.destroy() }); e.attackCooldown = 110;
    } else if (e.enemyType === 'shouter') { this.spawnProjectile(e.x, e.y-5, e.dir*1.4, 0); e.attackCooldown = 130; }
    else if (e.enemyType === 'lobbyist') { this.spawnDoubtCloud(this.player.x+(Math.random()-0.5)*40, this.player.y); e.attackCooldown = 180; }
  }
  hitPlayer(damage) {
    if (this.playerHitCooldown > 0) return;
    if (this.isBlocking) { audio.sfxBlock(); damage = Math.floor(damage * 0.2); }
    this.player.hp -= damage; this.playerHitCooldown = 30; this.player.setTint(PAL.red);
    this.time.delayedCall(200, () => { if (this.player.active && !this.isBlocking) this.player.clearTint(); }); this.shakeTimer = 3;
  }

  updateBoss(dt) {
    if (!this.boss || !this.boss.active) return;
    const b = this.boss;
    if (b.hitTimer > 0) { b.hitTimer--; if (b.hitTimer <= 0) b.clearTint(); }
    if (this.bossShoutTimer > 0) { this.bossShoutTimer--; if (this.bossShoutTimer <= 0) this.showBossShout(); }
    // Move boss head with body
    if (this.bossHead && this.bossHead.active) {
      this.bossHead.setPosition(b.x, b.y - 30);
      this.bossHead.setFlipX(b.flipX);
    }
    if (this.bossShoutText && this.bossShoutText.active) this.bossShoutText.setPosition(b.x, b.y - 44);
    if (b.stunTimer > 0) { b.stunTimer--; return; }
    if (b.attackCooldown > 0) b.attackCooldown--;
    const dx = this.player.x-b.x, dy = this.player.y-b.y, dist = Math.sqrt(dx*dx+dy*dy);
    b.dir = dx>0?1:-1; b.setFlipX(b.dir<0);
    const spd = this.bossPhase===2?0.9:0.45;
    if (b.dashTimer > 0) { b.dashTimer--; b.x += b.dir*3.5; b.x = Phaser.Math.Clamp(b.x, this.cameras.main.scrollX+14, this.cameras.main.scrollX+W-14); return; }
    if (dist > 35) { b.x += (dx/dist)*spd; b.y += (dy/dist)*spd*0.5; b.y = Phaser.Math.Clamp(b.y, LANE_TOP+10, LANE_BOT); }
    if (b.attackCooldown <= 0) {
      if (this.bossPhase===2 && Math.random()<0.3) {
        b.dashTimer=18; b.attackCooldown=80;
        const wt = this.add.text(b.x, b.y-34, '!!', { fontSize:'10px', fontFamily:'monospace', color:'#f04040' }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets:wt, alpha:0, duration:350, onComplete:()=>wt.destroy() });
      } else if (this.bossPhase===2 && Math.random()<0.4 && dist>50) {
        const wt = this.add.text(b.x, b.y-34, '!!!', { fontSize:'10px', fontFamily:'monospace', color:'#f04040' }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets:wt, alpha:0, duration:450, onComplete:()=>wt.destroy() });
        this.time.delayedCall(280, () => { if (!this.boss) return;
          this.spawnProjectile(b.x, b.y-5, b.dir*1.6, -0.5, true);
          this.spawnProjectile(b.x, b.y-5, b.dir*1.6, 0, true);
          this.spawnProjectile(b.x, b.y-5, b.dir*1.6, 0.5, true);
        }); b.attackCooldown=110;
      } else if (dist<40) {
        const wt = this.add.text(b.x+b.dir*14, b.y-22, '!', { fontSize:'12px', fontFamily:'monospace', color:'#f04040' }).setOrigin(0.5).setDepth(25);
        this.tweens.add({ targets:wt, alpha:0, duration:280, onComplete:()=>wt.destroy() });
        this.time.delayedCall(350, () => { if (!this.boss) return;
          if (Phaser.Math.Distance.Between(this.player.x, this.player.y, b.x, b.y) < 44) { this.hitPlayer(this.bossPhase===2?15:10); this.spawnSpark(this.player.x, this.player.y-8); }
        }); b.attackCooldown = this.bossPhase===2?65:95;
      } else { b.attackCooldown = 25; }
    }
    b.x = Phaser.Math.Clamp(b.x, this.cameras.main.scrollX+14, this.cameras.main.scrollX+W-14);
    this.bossHpBar.width = 62*Math.max(0, b.hp/b.maxHp);
  }

  updateProjectiles(dt) {
    for (const p of this.projectiles) {
      if (!p.active) continue; p.x += p.vx; p.y += p.vy; p.life--;
      if (p.label && p.label.active) p.label.setPosition(p.x, p.y);
      if (Phaser.Math.Distance.Between(p.x, p.y, this.player.x, this.player.y) < 14) {
        this.hitPlayer(p.fromBoss?10:5); this.stats.bubblesPopped++; if (p.label) p.label.destroy(); p.destroy(); continue;
      }
      if (p.life<=0 || p.x<this.cameras.main.scrollX-30 || p.x>this.cameras.main.scrollX+W+30) { if (p.label) p.label.destroy(); p.destroy(); }
    }
    this.projectiles = this.projectiles.filter(p => p.active);
  }
  updateDoubtClouds(dt) {
    for (const c of this.doubtClouds) { if (!c.active) continue; c.life--; c.setAlpha(0.3+Math.sin(c.life*0.1)*0.15); if (c.life<=0) c.destroy(); }
    this.doubtClouds = this.doubtClouds.filter(c => c.active);
  }
  updateUI() {
    this.hpBar.width = 62*Math.max(0, this.player.hp/this.player.maxHp);
    const p = this.player.hp/this.player.maxHp;
    this.hpBar.fillColor = p>0.5?PAL.hpGreen:(p>0.25?PAL.hpYellow:PAL.hpRed);
    this.scoreText.setText(`SCORE ${this.score}`);
  }
  showEndScreen(won) {
    this.endBg.setVisible(true);
    this.endText.setText(won
      ? `★ VERIFIED! ★\n\nScore: ${this.score}\nCombos: ${this.stats.combos}\nBubbles Popped: ${this.stats.bubblesPopped}\nMyths Bonked: ${this.stats.mythsBonked}\n\nPress J to play again`
      : `MISLED... TRY AGAIN\n\nScore: ${this.score}\nMyths Bonked: ${this.stats.mythsBonked}\n\nPress J to restart`
    ).setColor(won ? '#90f0a0' : '#f04040').setVisible(true);
  }
}

// Helper for background props
function sRect16(scene, x, y, w, h, dk, md, lt) {
  scene.add.rectangle(x+w/2, y+h/2, w, h, dk).setDepth(-1).setScrollFactor(1);
  scene.add.rectangle(x+w/2, y+h/2, w-2, h-2, md).setDepth(-1).setScrollFactor(1);
  scene.add.rectangle(x+w/2, y+h/2-1, w-4, Math.floor(h/3), lt).setDepth(-1).setScrollFactor(1);
}

// ============================================================
// PHASER CONFIG
// ============================================================
const SCALE = Math.min(Math.floor(window.innerWidth / W), Math.floor(window.innerHeight / H));
const game = new Phaser.Game({
  type: Phaser.AUTO, width: W, height: H, zoom: SCALE,
  pixelArt: true, backgroundColor: '#000000',
  physics: { default: 'none' }, scene: [GameScene], parent: document.body,
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
});
</script>
</body>
</html>
